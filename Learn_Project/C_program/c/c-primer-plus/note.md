C Primer Plus-- 学习记录
================================================================
- 目录  
    [第四章: 字符串和格式化输入/输出](https://github.com/GitNoWen/gitnowen/blob/master/arch_work/c/c-primer-plus/note.md#%E7%AC%AC%E5%9B%9B%E7%AB%A0%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA)  
    [第五章: 运算符, 语句, 左值](https://github.com/GitNoWen/gitnowen/blob/master/arch_work/c/c-primer-plus/note.md#%E7%AC%AC%E4%BA%94%E7%AB%A0%E8%BF%90%E7%AE%97%E7%AC%A6-%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E8%AF%AD%E5%8F%A5-%E5%B7%A6%E5%80%BC--%E8%BF%94%E5%9B%9E%E9%A1%B6%E9%83%A8)  
    [第六章: 循环 for, while ,do while](https://github.com/GitNoWen/gitnowen/blob/master/arch_work/c/c-primer-plus/note.md#%E7%AC%AC%E5%85%AD%E7%AB%A0%E5%BE%AA%E7%8E%AF--%E8%BF%94%E5%9B%9E%E9%A1%B6%E9%83%A8)  
    [第七章: 流程控制 if else, 三目? :](https://github.com/GitNoWen/gitnowen/blob/master/arch_work/c/c-primer-plus/note.md#%E7%AC%AC%E4%B8%83%E7%AB%A0%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6-%E8%BF%94%E5%9B%9E%E9%A1%B6%E9%83%A8)  
    [第八章: 缓冲, 重定向](https://github.com/GitNoWen/gitnowen/blob/master/arch_work/c/c-primer-plus/note.md#%E7%AC%AC%E5%85%AB%E7%AB%A0-%E7%BC%93%E5%86%B2-%E9%87%8D%E5%AE%9A%E5%90%91-%E8%BF%94%E5%9B%9E%E9%A1%B6%E9%83%A8)  
    [第九章: 递归和函数](https://github.com/GitNoWen/gitnowen/blob/master/arch_work/c/c-primer-plus/note.md#%E7%AC%AC%E4%B9%9D%E7%AB%A0%E6%8C%87%E9%92%88-%E6%95%B0%E7%BB%84-%E8%BF%94%E5%9B%9E%E9%A1%B6%E9%83%A8)  
    [第十章: 指针和数组](https://github.com/GitNoWen/gitnowen/blob/master/arch_work/c/c-primer-plus/note.md#%E7%AC%AC%E5%8D%81%E7%AB%A0-%E6%95%B0%E7%BB%84%E5%92%8C%E6%8C%87%E9%92%88-%E8%BF%94%E5%9B%9E%E9%A1%B6%E9%83%A8)  
    [第十一章: 字符串处理](https://github.com/GitNoWen/gitnowen/blob/master/arch_work/c/c-primer-plus/note.md#%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86-%E8%BF%94%E5%9B%9E%E9%A1%B6%E9%83%A8)    
    [第十二章: 存储类型](https://github.com/GitNoWen/gitnowen/blob/master/arch_work/c/c-primer-plus/note.md#%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0-%E5%AD%98%E5%82%A8%E7%B1%BB%E5%9E%8B-%E8%BF%94%E5%9B%9E%E9%A1%B6%E9%83%A8)    
    [第十三章:文件操作](https://github.com/GitNoWen/gitnowen/blob/master/arch_work/c/c-primer-plus/note.md#%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C-%E8%BF%94%E5%9B%9E%E9%A1%B6%E9%83%A8)  
    [第十四章:结构体](https://github.com/GitNoWen/gitnowen/blob/master/arch_work/c/c-primer-plus/note.md#%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0-%E7%BB%93%E6%9E%84%E4%BD%93-%E8%BF%94%E5%9B%9E%E9%A1%B6%E9%83%A8)  
    [随记](https://github.com/GitNoWen/gitnowen/blob/master/arch_work/c/c-primer-plus/note.md#%E9%9A%8F%E8%AE%B0-%E8%BF%94%E5%9B%9E%E9%A1%B6%E9%83%A8)    


## 第四章：字符串和格式化输入/输出
---
* 本章主要内容
      string.h  strlen()  
      stdio.h && sizeof() 
      #define && const  
      scanf() && printf()
 
### 4.1 char类型数组

```c
char name[10];
```
>  `char数组`储存字符串时, 应多留出一位用来存放`\0(null)` 结束符号  
> `"`双引号中的字符组成一个字符串, 且自动添加一个`\0`字符作为结尾`"`

### 4.2 `%s` 为一个数组输入/输出一个字符串

``c
printf("打印一个字符串%s \n", name);
```
    > %s 输出 name数组 中的字符串
    > %c 输出一个字符
    > name 数组名代表了数组首地址 name[0], 输出 name[0] 中的字符

```c
scanf("输入一个字符串 %s：", name);   
scanf("输入: %s ", &ch); //ch为非数组要加&取址符
```
    > %s 默认跳过 第一个字符前 的 所有空白字符 直到 下一个空白字符前结束  
    > %c 读取一个字符输入, 包括空白字符
        * 需要注意%c如果不前导空格将会读取空白字符和换行符
#### 2020-07-26更新
在使用scanf读取一串字符时 %s会在遇到空白符或\0结束

### 4.3 *字符* 和 *字符串* 的区别

- 字符串以`\0`结尾

```c
"a" == 'a'+'\0' // 字符串
'a' == 'a'     //字符
```

### 4.4 `sizeof` 和 `strlen`
> 此段初学者可以仅作了解  

```c
printf("name[40] %s, sizeof = %zd, strlen = %lu, sizeof = %u",
   name, sizeof(name), strlen(name), sizeof(name));
```
1. `strlen` 给出字符串的长度，但不包括字符串的结束符`\0`  
    - `strlen` 是一个函数
    - 可以是字符串开头，中间某个位置，或某个不确定的内存区域

2. `sizeof()`给出以字节的计算结果，包含了空字符`\0` [此段参考百度百科](https://baike.baidu.com/item/sizeof/6349467?fr=aladdin)  
    - `sizeof` 在`c99`之前都是在编译阶段进行,所以它可以作为一个常量表达式使用,`c99`开始支持在运行期间求值  
    - `sizeof`是一个求字节操作符  
    - 参数可以是类型名、表达式、函数调用、变量、数组  
    - 求函数参数中的数组大小  
    ```c
    int num (int ar[2]){

    sizeof (ar);  //此处求值为4/8字节分别对应32位和64位计算机,因为ar被解释为指针,数组传参是地址形式
    }
    ```
    - 给出`变量类型`或`函数调用`(不会产生函数调用)在内存中所占字节大小  
        ```c
        char foo(){}
        sizeof (foo());//返回char类型字节大小
        int n;
        sizeof (int);//返回int类型字节大小
        int a[2];
        sizeof (a);//返回int*2字节大小
        ```
    - sizeof 不能计算无法确定类型的表达式(`void`)、`位域/位段`成员和函数名
        ```c
        void foo (){}
        sizeof (foo);    // 函数名非函数调用err
        sizeof (foo()); //函数返回类型为void,err
        struct f {

          int a:1;   //使用位段/位域
        };
        sizeof (f.a); //计算位域成员err
        ```

### 4.5 预处理`#define` 明示常量 和`const`只读变量

- `#define NAME 1` 代表在编译时一行一行的将代码中的 `NAME` 替换为`1`常量,且不以`;`结尾  
- `const int a = 1;` 声明了一个**只读**的变量，此变量的值不可改变, 以`;`结尾  
* 使用`#define` 的一个好处是可以先将常量的名称写好，值可以留给后面在去决定

### 4.6`limits.h` &&`float.h`

- `limit.h`此头文件中定义了整数可移植的明示常量
- `float.h`中定义了可移植的浮点型可移植明示常量  

#### 此处的可移植

> 编译器会根据不同的系统自动选择相应的类型标准

### 4.7 `printf`&&`scanf`中的转换说明修饰符

1. `printf`
  - `%()d` :
    > (标记) ：`-` 左对齐，`+`自动识别添加 `-, +`, `空格`, `#`, `0`  
    > (数字) ：最小字段宽度，自动扩充字段特性  
    > (.数字)：精度，在`%e`, `%E`, `%f`中表示小数点后的位数,
         %g, %G 中表示最大有效数位,
         %s 中待打印字符的最大字段宽度,
         对整型转换，代表最小字段宽度,
         只有. 表示其后跟一个`0` ：`1.0`    

    > (t) :和整型转换一起用：`%td`，表示`pptrdiff_t`,两个指针差值的类型  
    > (z) :用于`sizeof` && `strlen`

### 4.8`scanf`函数与`printf` 区别

- 对于`float` 和`double`，`printf` 都用`%f, %e ,%E %g %G` 转换说明  
- 而`scanf`将`%f, %e ,%E %g %G` 他们用于`float`类型,`double`类型用`%lf`修饰符  
- 符号 `*`   
    - `sacnf ("%*d %d", &d, &a);` 中作为抑制赋值, 跳过`d`输入项  
    - `printf ("%*d", input, num);` 读取`input`用户指定的一个字符宽度 `d` 读取 `num` 
- 数字
    - scanf会在字段宽度和第一个空白字符处停止输入，也就无法利用字段宽度来读取多个单词,
     如果第一个输入就不符合，scanf会将其放回栈中,
     在程序下一次读取输入时，读取到的仍然是上一次放回的字符,
     多个说明符的scanf会在第一次出错时就停止读取输入

- `scanf("允许把普通字符串放在里面，但是除了空格以外的输入其他必须和""中的一样，%s", &a);`
- scanf 格式字符串中的空白代表跳过下一个输入项前的所有空白，除了`%c`其他的说明符都会自动跳过待输入项前的所有空白
    - `%c`格式字符串读取每一个输入的字符，包括空白字符

#### - printf,scanf的返回值  
##### 1. 大部分的c语言函数都有返回值  
1. `printf`
    - 成功：输出字符的个数,但是不包括结尾的`'\0'`
    - 错误：返回一个负值  

2. `scanf`
    - 成功：返回读取到的项数
    - 读取到文件结尾或遇到硬件问题：返回一个负值 EOF(-1)
    - 错误：未读取任何项，输入和需要读取的项类型不匹配时 返回0

### 4.9 `scanf`其他

在c语言中scanf将传入的值放入栈中
```
enter: a b c d

01010010 | 01001000 | 00100100 | 00010001
```

然后`printf`按照转换说明符在栈中读取相应的字节数,
如果转换符和参数对应的类型不一致,
就会发生读取错误的字节,
造成少读或则多读的打印错误

---

## 第五章:运算符, 表达式, 语句, 左值  [返回顶部](https://github.com/GitNoWen/gitnowen/blob/master/arch_work/c/c-primer-plus/note.md#c-primer-plus---%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95)

> while , typedef  
> 运算符：=、-、 * 、/、%、++、--、(类型名)  
> 复合语句，自动类型转换，强制类型转换  
> 有参数的函数  

### 5.1 while , typedef

1. `while (条件)  {待执行语句}`

2. `typedef int aint;` 定义一个`int`类型的别名`aint`来表示`int`类型  
    - `aint a = 1;`

### 5.2 基本运算符

1. `=` :从右向左运算 ,其左项为一个地址(变量)  
    - `a = a + b;`  

2. `-`, `+`:一元运算符
    - `-(-12) == 12`

### 5.3 左值，数据对象，右值

1. 数据对象
    - c语言中，用于储存值的数据储存区域称之为数据对象

2. 左值
    - 用于标识或定位存储位置的标识符

3. 右值
    - 能赋值给可修改左值的量,且本身不是左值

### 5.4 除法运算符 '/'

- 整数除法会截断小数部分(丢弃),混合整数和浮点数计算的结果会是浮点数
**c99** 规定负数除法运算使用**趋零截断** `-3.8` 转换为 `-3`
    - `7 /4` is `1` 丢弃小数部分
    - `7./4` 或 `7.0/4` is `1.75` 保留小数部分 结果为浮点数

### 5.5 运算符的运算顺序和优先级(高往低)
```c
1. ()                           左往右
2. -, + (一元), ++, --, sizeof  右往左    - 逻辑运算符 ！
3. * , /, %                     左往右
4. +, - (二元)                  左往右
5. <, >, <=, >=关系运算         左往右
6. &&                                 
7. ||                                 
8. ==, !=                       左往右
9. =, +=, -=, * =, /=, %=       右往左
```
### 5.6 其他运算符

#### 1. `sizeof` 和 `size_t类型`

- `sizeof` 返回一个 `size_t` 类型的无符号整数
- c头文件系统 可以用typedef 把 `size_t` 作为 `unsigned int` 或者 `unsigned long` 的别名,
编译器会根据不同的操作系统替换标准

#### 2. 求模运算符 '%'

- 求模运算符，只能用于整数运算，不能用于浮点数  
- 负数求模也遵从c99的趋零截断
```c
 11 /  5  =  2    |  11 %  5 =  1
 11 / -5  = -2    |  11 % -5 =  1
-11 / -5  =  2    | -11 % -5 = -1
-11 /  5  = -2    | -11 %  5 = -1
```
- 标准规定 ：无论何种情况都可通过此种方式求模
```c
a - (a/b)*b == a%b
-11 - (-11/5)*5 = -11 - (-2)*5 = -11 - (-10) = -1
```

#### 3. 运算符 + + 和 --

`a++ | ++a | a-- | --a`
- 递增，递减对const限定的只读变量不起作用，一般的编译器会进行报错  
1. 两者区别在于:  
    - 前缀和后缀模式的优先顺序不一样
```
a = 2;
b = a++;  | b = 2, a = 3;
b = --a;  | b = 1, a = 1;
```
2. 递增递减只影响一个左值，`(a+b)++`此项不成立  
    - 组合`(a+b)`不是一个可修改的左值

* 在复杂的表达式参数中对出现多个相同的变量使用递增递减时会出现意想不到的错误  
* 编译器会自行选择先对函数中的同一个变量中的一个参数求值  
```c
int a = 2;
print("a = %d & a++ = %d\n", a, a++);
a =2;
print("a = %d & ++a = %d\n", a, ++a);
a =2;
print("a = %d & a++ = %d & --a = %d\n", a, a++, --a);
-----------------------------------------------------
//out: 
     a = 3 & a++ = 2
     a = 3 & ++a = 3
     a = 3 & a++ = 1 & --a = 2
```
* 当一个表达式中有多个相同的变量参数时对其进行递增
    a = num/2 + 5 * (2 + num++) //得出的结果可能和预期值不同  

3. 做到以下两点可避免这种情况：
    1. 如果一个变量出现在一个函数的多个参数中，不要在函数的参数列表中对该变量使用递增递减运算
    2. 如果一个变量多次出现在一个表达式中，不要在表达式中对该变量使用递增递减运算符

### 5.7 表达式和语句

- c语言中的每一个表达式都有一个返回值
- 声明 不是一个表达式
```c
 (3 > 2)         : 1
 (3 < 2)         : 0
 (q = (3 + 2))   : 5
 (5 ==  (3 + 2)) : 1
```
- c语言大部分语句都由 `;` 结尾
- 单独一个`;`分号表示一个空语句, 就是什么都不做

### 5.8 副作用和序列点

1. 术语 副作用 :对数据对象或文件的修改  
    - c语言的目的是对`3+5`进行求值，而将`(3 + 5)`的结果赋值给`states`改变了该对象的值,则是它的副作用  
`states = 3 + 5;`


2. 术语 序列点 :在该点上，所有的副作用都会在进入下一条命令前发生
    - `;` 分号标记了一个序列点,还有一些运算符也是序列点，此外任何一个完整的表达式的结束也是一个序列点  

3. 完整的表达式：任何嵌套表达式的最外层，没有更大的表达式了，就是一个完整的表达式
```c
while (num++ < 10){     //(num++ < 10)就是一个完整的表达式
  printf("%d \n", num);
}
y = (4 + x++) + (6 + x++); //(4 + x++)并不是一个完整的表达式
```
4. c语言保证在`;`序列点前完成*两次*`x++`的累加，但却不保证在对`(4 + x++)`求值后立即进行`x`的累加

### 5.9 复合语句(块)

```c
{
  用话括号括起来的一条
  或多条语句
}
```

### 5.10 类型转换

- c语言采用了一套自动类型转换的规则

- 升级/降级:
  > 类型转换出现在表达式中 `unsigned, signed, char, short` 都会被自动转换成`int/unsigned int`  
  > `(short和int一样大, unsigned int 比 int 大, unsigned short 会转换为unsigned int` 都是由较小的类型转换为较大的类型  
  > 涉及两种类型的计算, 两个值都会被转换成两种类型的更高级别  
  > 类型的级别(高至低)  
    >> long == long int 长整型 int被省略了  
    >> long double  
    >> double  
    >> float  
    >> unsigned long long  
    >> long long  
    >> unsigned long  
    >> long          //当long 和 int大小相同时 unsigned int比long级别高  
    >> unsigned int  
    >> int  
    >> short 和 char没有列出是因为他们已经升级到了int 或unsigned int  
  > 但作为函数参数传递时, cahr 和 short转换为int,float 转换为double，函数原型会自动覆盖升级  

* 一般类型升级并不会造成麻烦，但是类型降级会导致降级的类型可能存放不下原来的数据

* 待转换和目标类型不匹配：
    - int 转换 8 位的unsigned char ,待赋值原始值求模256: unsigned char UInum; UInum = 123456789; 最后UInum == 21;
         - 利用公式 `a-(a/b)*b`
    - 待赋值为整数，目标类型是有符号整型,结果因实现而异
    - 待赋值为浮点数，目标类型是整型，该行为是未定义的
    - 当浮点型降级为整数类型 小数点后的位数会被截断丢弃,23.1, 23.45截断为23

#### 单精度`float`, 双精度`double`

- 单精度`float`,精度为`6～7`位  
- 双精度`double`,精度为`15~16`位  
    1. 在C语言中所有的浮点数(类似`1.23`),都是双精度  
    2. 所以在使用的时候要特别注意类型转换   
        - `float val = 1.23f; 或 float val = (float)1.23;` 进行类型转换
- 一般在使用的时候尽量使用单精度浮点数类型  
    - 因为双精度浮点数在计算机中运行比单精度要慢，也更占资源  

### 5.11 强制类型转换
```c
//(类型名)变量名
int num;
num = 1.7 + 1.2;          //自动转换
num = 3;
num = (int)1.7 + (int)1.2;//强制转换
//out:
num = 2;
```

### 5.12 带参数的函数

1. 有返回值的函数声明：`类型 函数名(参数列表, int n,float b);`  
2. 无返回值的函数声明：`void 函数名(参数列表, int n,float b);`  
3. 函数头与声明相对应：`类型/void 函数名(参数列表, int n,float b){ 执行代码 }`  
4. 函数不接受任何参数：`类型/void 函数名(void);`  

* 在函数中声明的变量名是私有的，也就是不会和其他函数中同名的参数发生冲突   
```c
int num (int a); // a 为声明私有
int main (void){
  int a; // main中同名变量
}
```
* 当参数列表的值类型不匹配时，会进行自动类型转换

## 第六章:循环  [返回顶部](https://github.com/GitNoWen/gitnowen/blob/master/arch_work/c/c-primer-plus/note.md#c-primer-plus---%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95)

> 关键字：`for, while, do while`  
> 运算符：`<, >, >=, <=, !=, ==, +=, -=, /=, *=,%=`  
> 函数:`fabs()`  
> 使用关系运算符构建控制循环的表达式  
> 循环常用的数组  
> 有返回数的数组  

### 6.1 `while` & `for`
- `while`
    - `while` 循环条件仅有一个参数列表,`while`适合完成简单的循环任务  
    - `while(测试参数列表) {语句块}`  
    - 进入`while`循环之前对参数列表进行测试是否为真值，是进入否跳过循环
    - C风格读取循环
        - `while (scanf(" %d", &num) == 1){ printf("\n"); }  //利用scanf的返回值做检测`
    - `while`的参数列表中的表达式是不带`;`分号结尾的
```c
while( expression ){
  statement;
}
```  
- `statement` 可以是以`;`分号结尾的语句或是单独一个`;`的空语句用来表示循环体什么都不需要做，也可以是以`{}`括起来的复合语句  
- `expression` 的值为`非0`时`while`进入第一次循环,当值为`0`跳出循环,或者使用`break`跳出循环   


- `for`适合完成复杂的循环任务:  
- `for`有三个参数列表   
```c
for (进入for执行一次; 条件表达式; 每次循环完成语句块后执行一次){
  语句块;
}
```  
- 基本的`for`循环参数列表`(变量初始化; 循环条件检测; 变量更新)` `for`括号包含了三个参数列表，他们都是*完整表达式*  
- `for`第一和第三个表达式都可以是任意表达式,第一个表达式在`for`最开始运行一次且只运行一次，第三个表达式每次循环结束时运行一次

#### 2020-07-10 
今天补上一个漏
在c语言中for循环的第一个参数
- `for (int i= 0, float b = 0;;)`
这种写法是错误的, 不能声明多个变量
而且对于效率来说,不应该在for中声明变量

### 6.2 不确定循环和计数循环

- 两种循环结构的区别是，计数循环可控性更高
    - 不确定循环：指在测试循环表达式为假之前，并不知到循环需要进行多少次
    - 计数循环：在进入循环前已知循环将进行多少次

### 6.3 关系运算符

`<, <=, ==, >=, >, !=`

### 6.4 `math.h` // `fabs()`函数,浮点数比较
- 虽然关系运算符可以比较浮点数大小，但是浮点数的舍入误差可能会导致逻辑上相等的两个数不相等
- `fabs()`返回一个浮点数的绝对值，无符号的值

### C语言中除`0`以外都视为真值

### 6.5 _____ _`_Bool`变量 和 `stdbool.h`

- `_Bool input;` //变量`input`只储存`0`和`1`分别代表假和真, 其他任何的非零值都会变成`1`
- `c99`协议提供了`stdbool.h`头文件用`bool` 代替`_Bool`, 并分别用`false,true`分别定义为了`0, 1`
- 使用该头文件后可以与`c++`兼容，`c++`使用`bool,false,true`作为关键字

### 6.6 关系运算符的优先级

- 关系运算符的优先级比运算符`-，+`低但是比`=` 高
- 关系运算符之间的优先级：
> 2. 高优先级:
> > `<, <=, >, >=`
> 2. 低优先级:
> > `==, !=`  
    - 关系运算符的结合率也是左往右

### 6.7 其他赋值运算符：

- `+=, -=, *=, /=, %=`他们比一般的运算形式更加高效, 当要在for中放入复杂的表达式时很有用  
    - 赋值运算符和赋值符优先级一样, 都比算数运算符低

### 6.8 `,`逗号运算符

- 逗号运算符保证了被它分割的表达式从左到右执行，它相当于一个序列点，其次整个逗号表达式的值为最右侧项的值
```c
 x = (y = 3, (z = ++y + 2) + 5) 
 x = (z = ++y + 2) + 5  //x的值为逗号最右侧表达式的值

 houseorice = 249,500; //c编译器将其解释为一个逗号表达式
 houseorice = 249;
 500;
 houseorice = (249, 500); //houseorice = 500;
```
### 6.9 出口条件循环 `do while`

- `for`和`while`这两个都是入口条件循环，在测试条件为真时才会执行循环
- `do while`是出口条件循环，在表达式为真时会重复执行循环任务，表达式为假时才跳出循环
    - 他们的区别是`for`和`while`在表达式为假时循环一次都不会执行 
    - `do while`是出口条件, 会先进行一次循环然后再判断表达式的值
```c
do{
  循环体
}while(为假结束循环)
```

### 6.10 C语言不会检查数组的下标是否正确，下标从`0`开始计数其他的元素依次排列

- c语言中的下标都是从`0`开始
    - 将下标和普通的表示区分开来，以免在程序中理解错误
    - `[7]` 代表`0~6`
    - `7`代表`1~7`

### 6.11 函数返回值

- 声明一个用户创建的函数，应保证函数的类型和返回值的类型相对应，函数传参类型相对应
- 带返回值的函数关键要素:   
    - 声明函数 
    - 调用函数 
    - 定义函数 
    - 使用关键字`return`

### 第六章关键概念

1. 使用循环
> 确保循环测试条件能使循环结束  
> 确保测试表达式中的值都已经初始化  
> 确保循环每次迭代都更新测试值  

2. 函数  
> 原型声明  
> 调用函数  
> 定义函数  


## 第七章:流程控制 [返回顶部](https://github.com/GitNoWen/gitnowen/blob/master/arch_work/c/c-primer-plus/note.md#c-primer-plus---%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95)

> 关键字:`if, else, switch, continue, break, case, default, goto`  
> 运算符:`&&, ||, !, ?:`  
> 函数:`getchar(), putchar(), ctype.h`  

### 7.1 `if else`选择嵌套函数

- 在`c99标准`的规定中，编译器至少要支持`127`层`if`嵌套
- `else` 和 `if` 的匹配规则为: 最近原则,有特殊要求应用花括号组成复合语句

- 即使`if`由复合语句构成, 整个`if`语句仍视为一条语句
- `if` 和 `else` 之间只允许存在一条语句， 在有多条语句时应将其用花括号组成复合语句
```c
if () {
...
}else if (){
...
}else{
...
}
```
### 7.2 `getchar(), putchar()` 在`stdin.h` 中的预处理宏函数

- 字符输入/输出函数,他们只处理字符, 所以相对于`scanf`和`printf` 更快，更简洁，而且他们不需要转换说明
- `getchar()`函数不带任何参数, 它从输入栈中返回下一个字符,下列语句效果相同:  
`ch = getchar();     scanf("%c", &ch);`  
- `putchar()`函数打印打印一个参数, 此函数根据最后一个字节来确定要打印的字符  
`puterchar(ch);      printf("%c", ch);`

### 7.3 处理字符的头文件`ctype.h`

- 包含了处理字符的函数：
>    函数名     以下参数时返回真

> > `isalnum()`     ---字母或数字  
> > `isgraph()`     ---除空格外任意可打印字符  

> > `isalpha()`     ---字母  
> > `isupper()`     ---大写字母  
> > `islower()`     ---小写字母  

> > `isdigit()`     ---数字  
> > `isprint()`     ---可打印字符  

> > `isblank()`     ---标准空白字符（空格, 水平制表符, 换行符）  
> > `isspace()`     ---空白字符(空格, 换行符, 换页符, 回车符, 垂直制表符, 水平制表符)  

> > `ispunct()`     ---标点符号（除空格，字母数字字符以外的任何可打印字符  

> > `iscantrl()`    ---控制字符, `Ctrl+B`  
> > `isxdigit()`    ---十六进制数字符  

- 字符映射函数

> `tolower()`     ---如果参数是大写字符，该函数返回小写字符，否则返回原始参数  
> `toupper()`     ---如果参数是小写字符，该函数返回大写字符，否则返回原始参数

### 7.4 逻辑运算符 `&&`, `||`, `!`, --与，或，非

- 备选拼写头文件 `iso646.h` C语言是在美国用标准美式键盘开发的语言，并非所有的键盘都是一样的符号
- 因此`c99`新增了可替代逻辑运输符的拼写
```c
&& == and
|| == or
!  == not
```
- 优先级：
    - `!` 比乘法等级高, 与递增相同, 比圆括号低
    - `&&` 比 `||` 高, 比关系运算符低, 比赋值运算符高
    - `||` 比 `&&` 和关系运算符低, 比赋值运算符高

- c语言保证逻辑运算符，求值顺序*从左往右*, `&&` 和 `||` 都是序列点  
- `a < b || b > a` --如果`a<b`则不进行后面的判断

### 7.5 三目运算符`? :`

- 三目运算符相当于 `if else`
- 条件运算符: C语言唯一一个三元运算符, 分为两个部分, 三个运算对象
```c
// 三目运算符 expression1 ? expreesion2 : expreesion3
puts ((3 > 2) ? "yes" : "no"); //expreession1为真, 打印 yes , 否则打印 no

// 条件控制 if else
if (3 > 2){

  puts ("yes");
}else{

  puts ("no");
}
```

### 7.6 辅助循环`continue` `break`

- `continue`:进入下次循环
- `break`   :跳出本层循环

### 7.7 `switch, case, default, break`
    - 这里`default`有个坑，识别`NULL`时会报错
```c
switch (expreesion)
{

  case '1':
    statement1;
    break;
  ...
  case n :
  case m :      //双重标签n m都执行statement
    statement n;
    break;

  default:
    statement;
}
```
- 一般C语言的一个`case`关键字只能指定一个值, 不能使用一个范围
    - `case 1~2: //错误`

- 有一种特殊的表示范围的技巧
```c
swicth(ch){

  case 'a' ... 'A' : 
    statement1;
    break;
  case 'b' ... 'B' :
    statement2; 
    break;
    
  default:
    statement3;
}

```


### 7.8 跳转语句`goto`

- 一般情况下我们不提倡使用`goto`,
- C语言程序员接受一种`goto`使用的方法  
    - 当嵌套循环出现问题时`break`通常只能跳出一个循环, 而`goto`可以跳出多个循环
```c
for (){

  for(){

    goto part;
  }
}

part: statement;
```

## 第八章: 缓冲, 重定向 [返回顶部](https://github.com/GitNoWen/gitnowen/blob/master/arch_work/c/c-primer-plus/note.md#c-primer-plus---%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95)  

> 介绍输入输出，缓冲输入，无缓冲输入  
> 如何通过键盘模拟文件结尾  
> 使用重定向将程序和文件链接  
> 创建更友好的界面  

### 8.1 缓冲

1. 回显无缓冲，用户输入后立即重复打印该字符  
2. 有缓冲，在用户输入`Enter`之前程序处于等待状态  
    - 缓冲分为两种  
        1. 一种完全缓冲i/o  
        2. 一种行缓冲i/o  
> 完全缓冲  
> > 当缓冲区填满时才刷新缓冲区通常出现在文件输入中  

> 行缓冲  
> > 出现换行符时刷新缓冲区，键盘输入通常是行缓冲输入

3. `ANSI C` 和 后续C 标准都规定输入是缓冲的,主要原因是有些计算机不支持无缓冲输入  
   为此c语言提供了无缓冲输入的一些特殊函数,其原型在conio.h头文件中  
   带回显无缓冲getche(), 不带回显无缓冲getch()  

- `unix`系统中可以使用`ioctl()`函数指定待输入的类型然后用`getchar()`执行相应操作  
- `ANSI C`中用`setbuf(), setvbuf()`控制缓冲,但受限一些系统的内部设置,这些函数可能不起作用 
    - 这意味着能否进行无缓冲输入取决于计算机


### 8.2 文件， 流， 键盘输入

> 1. 文件的操作：  
> > - 打开，读取，写入，关闭  
> 2. 流：  
> > - 是一种实际输入输出映射的理想化数据流  
> 3. 键盘输入：  
> > - C语言将输入和输出设备视为储存设备上的普通文件  
- 有`stdin`流表示键盘输入流, `stdout`流表示屏幕输出流, 而标准的i/o包则负责处理这两种文件流  

### 8.3 文件结尾

- 曾经的大部分计算机使用`ctrl+z`来作为文件结尾, 也有一些是以文件的大小来判定是否结尾  
  无论系统如何检测文件结尾, 在C语言中, 用`getchar(), scanf()`读取到文件结尾时将返回`EOF(-1)`  
`while ((ch = getchar()) != EOF)   //检测是否读取到文件结尾`

### 8.4 重定向和文件

- 默认情况下, C程序使用标准的i/o包查找标准输入作为输入源  
    - stdin流是将数据读入的常用方式，我们可以让一个程序从文件中查找输入，而不是从键盘  
- 程序可以通过两种方式使用文件
> > 1. 使用特定的函数来打开文件，读取文件，写入文件， 关闭文件
> > 2. 设计能与键盘和屏幕交互的程序，通过不同渠道的重定向输入至文件和从文件输出  

- 重定向：就是让程序使用文件而非键盘和屏幕来输入输出

1. 假如一个文件名为`words`
2. 一个文字处理程序`echo_eof`
- 将输入重定向  
> 1. `echo_eof < words`  
> > `<` 该运算符将`stdin`流和`words`文件相关联  

> 2. `echo_eof > mywords`  
> > 新建一个`mywords`文件, 如果已有将会擦除其数据重新将`echo_eof`程序的输出写入进去  
> > `>` 该运算符将`stdout`输出流定向到`mywords`文件中  

- 在某些dos系统中定向符两侧不能有空格

## 第九章:指针, 数组 [返回顶部](https://github.com/GitNoWen/gitnowen/blob/master/arch_work/c/c-primer-plus/note.md#c-primer-plus---%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95)

> `return`
> `*`(一元), `&`(一元)
> 函数
> 指针
> 递归

### 9.1 形参，实参

- 形参是函数声明中定义的变量  
    `int num (int a, int b); // 函数声明`
- 实参是主调函数传递给被调函数实际的值  
    ```c
    int main (void){

      int a,b;
      a = b =1;
      num (a, b); // 传参
      return 0;
    }
    ```

### 9.2 递归

1. C语言允许函数自己调用自己，称之为递归，使用递归的难点在于如何结束递归，否则它会无限递归  
2. 任何可以使用循环的地方都可以使用递归,相对于循环递归方案更简洁，但却没有循环效率高  
3. 递归会占用大量的系统资源
    - 递归的调用，首次调用函数称为第一级调用，第二次调用为第二级以此类推，
    - 在最后一级调用结束后，依次从最后一级调用将权限返还给上一级,然后继续执行调用函数接下来的指令，
    - 若没有指令需要执行则将权限返还上一级然后重复相同动作

- 每一级递归的变量都为本级调用私有，互不影响  
- 递归在处理倒序相对循环更加容易  

### 查找地址＆，取址运算符

`&n` 表示`n` 的地址

### 9.3 指针

- `*` 间接运算符， `＆`　地址运算符  
- 当需要从函数中传回多个值时需要使用指针，`return` 只能传回一个值

- 简单的指针运用,声明一个指向`int` 类型的指针变量`p`  
```c
int * p;

1. int n = 2;       //声明一个int 变量n 值为２
2. int m;          //一个int变量m
3. int * p;       //声明一个指针变量p
4. p = n;        //将p指向n的地址
5. m = *p;      //* 运算符解引p所指向的地址n中所储存的值,然后将其赋值给m
```

## 第十章: 数组和指针 [返回顶部](https://github.com/GitNoWen/gitnowen/blob/master/arch_work/c/c-primer-plus/note.md#c-primer-plus---%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95)

### 10.1 数组  
#### 1. 数组声明  

- 数组下标也称索引，从`0~7`，一共包含来`8`个`int` 元素所组成的序列
```c
int powers[8] = {1,2,3,4,5,6,7,8,9};
```

- 只读数组
```c
const int powers[8] = {0};        //将所有元素都初始化为0
```

#### 2. 数组初始化

1. 部分初始化数组  
```c
int power[8] = {1,2};          //编译器将元素０和１初始化为1，2剩余的元素都初始化为0
int power[] = {1,2};          //编译器会自动将数组大小设置为2
```

2. 指定初始化
    - 数组初始化根据列表依次进行，有指定初始化则指定元素初始化  
    - 如果已初始化过的元素再初始化，则值为最后初始化的值  
```c
int power[4] = {1,2, [3] = 4, [1] = 4}; //c99标准
```
```c
int power[] = {1,2,3,4,5,6,7,8,9}; //自动初始化下标
用sizeof power / sizeof power[0] 可以求出数组中有多少元素
```
- 数组使用花括号赋值只有初始化时才有效  
- 使用数组要确保数组下标不会越界，一般编译器只会对其发出警告，然后进行编译，下标越界可能造成意想不到的错误

### 10.2 二维数组

1. 数组操作时需要注意不要对数组名进行递增递减操作，因为数组名其实是一个指向`const`的指针  
    1. 声明一个二维数组，`power`拥有`4*12`个`int`元素,`4`个元素组中分别各有`12`个`int`元素
    ```c
    int power [4][12]; //二维数组声明
    ```
    2. 声明并初始化二维数组  
    ```c
    int power [2][2] = { //一个2×2的二维数组
     //1  2, 纵
     { 1, 2},   // 1, 横
     { 3, 4}   // 2
      };  
    ```

2. 某个列表中的数值个数超出元素个数时，会出错，但是不会影响到其他列表的初始化  
```c
int power [2][2] = {
  {1, 2, 3}, //出错
  {3, 4}    //不会影响到这个列表的初始化
}
```

3. 如果省略内层的花括号   
   > 如果保证初始化的数值个数正确，则初始化效果与上面一样  
   > 若数值不够则按照初始化列表中的值先后依次初始化，直到所有值用完，后面没有初始化的元素统一初始化为0  
   > 可以省略`x`轴不填，编译器将会按照初始化列表自动填值`2`  
```c
int power [2][3] = {  //２×３总有６个元素
  1,2,3,4            //只有４个元素
}
```

### 10.3 指针

> 1. 它能完成一些特殊操作
> 2. 指针操作的对象和指针的类型要相同
> 3. 指针操作相关的操作符
    - `*` 间接运算操作符:　解引地址所指向的变量的值
    - `&` 地址运算符    :  引用变量在内存中所在的地址
---

- 在计算机中，地址按字节编址
- 对地址的操作跟指针的类型相关
```c
int a = 2;       //int 类型a 在地址中占用４个字节
int * pa = &a;  //pa指向a所在的内存地址
pa + 1;        //表示pa所指向的a 的内存地址＋上１个int所占４个字节的大小,在内存的角度上就是增加了４个字节|指针越界
* pa + 1;     //表示 pa解引用a　地址中的值＋１, 2+1 = 3
& pa;        //表示pa指针所在的内存地址
```

### 10.4 函数传参

    - `int sum (int ar[], int );`
    - `int sum (int *ar, int n);`

### 10.5 对形式参数使用`const`只读限定

```c
int sum (const int ar[], int n ); == int sum (const int (*ar), int ); 
```
- 这样在函数操作数组时就不会修改数组中的值，可以有效避免误操作修改数组的值  

### 10.6 `const`详解

- 1. 声明指向`const`类型的指针  
    - 指向`const`的指针无法修改它指向的地址中的值，但是可以更改它的指向  
    ```c
    const int * pr; //不能改变它所指向地址中的值的
    int ar[4] = {0};
    pr = ar;
    *pr = 1;     //试图使用const限定的只读指针去修改ar[0]中的值是无法实现的,因为pr被const限定为只读指针
    pr++;       //将指针指向下一个地址ar[1], 这是没有问题的
    ```

- 2. 指向`const`的指针要注意的规则  
    - 除了可以将`const`指针指向`const`数据，还可以将指向`const` 指针指向非`const` 指针中的地址  
    ```c
    doule rates[5] = {0};
    const double locked [5] = { 1, 2, 3, 4, 5 };
    const double * pr = &rates [3]; //初始化有效
    pr = rates;                    //有效,数组名是一个地址
    pr = locked;                  //有效
    ```

- 3. 普通指针只接受同类型的非`const` 数据  
```c
double rates [5] = {0};
const double locked [5] = { 1, 2, 3, 4, 5 };
double * pr = rate;   //有效
pr = locked;         //无效
pr = &rate[3];      //有效
```

- 4. 声明一个不能指向别处但可以修改当前值的指针
```c
double * const pr = rates;    //这样指针pr只能指向rates[0],不能改变指向,但可以改变地址中的值
*pr = 9.0;                   //这是有效的
```
- 5. 指向`const` 的`const` 指针
```c
const double * const pr = rates;   //指针pr只能指向rates[0],且无法修改rates[0]的值
```

> 指向`const` 的指针通常用于函数的形参中，表明函数不会使用指针改变数值
> 需要注意的规则，将指向`const`的指针初始化为指向`const` 或非`const`数据的地址,或赋值是合法的
> 但是只能把非`const`数据的地址赋值给普通指针

### 10.7 指针和一维数组

1. 数组名是一个指向非常量的常量指针,指向变量的`const`指针   
```c
int a[10];      //一维数组
int * const a; //数组名a
```
2. 将数组名(指针常量) 赋值给普通指针
    - 因为他们都指向了同一类型的数据
    ```c
    int a[2] = { 1, 2 }; //一维数组a, 数组名a是一个指向非常量的常量指针，即int * const a;　不能改变它的地址但是可以改变它的值  

    //它指向了a[0] 首元素的地址
    int * prz  = a;
    *prz + j;   //a[0] + j;
    ```

### 10.8 指针和二维数组

* 这里的`zippo`都为数组名  

1. 这个二维数组由`2`个特殊的一维数组`zippo[0] - zippo[1]` 组成  
    - `zippo`二维数组名指向这个特殊一维数组的首元素`zippo[0]`  
    - `zippo[0]`指向首元素`zippo[0][0]`  
    `int zippo [2][2] = { 1, 2, 3, 4 }; //二维数组名是一个的行指针`

```c
zippo                      //二维数组名,指向&zippo[0]的行指针
zippo[0],    zippo[1]     //2个特殊一维数组名，都是指向各自数组首元素的数组地址
zippo[0][0], zippo[1][0] //分别是2个一维数组中的首元素
  1            3        //２个一维数组首元素的值

zippo + 1             //行指针指向下一个地址, &zippo[1] 数组名　
*(zippo + 1)         //指向 &zippo[1],解引用得 zippo[1], *zippo[1] 再次解引用得3
*(*(zippo + 1))     //对&zippo[1] 进行解引用，得3
zippo[0] + 1       //该指针指向&zippo[0][0]的下一个地址 &zippo[0][1]
*(zippo[0] + 1)   //即解引zippo[0][1]中的值,2
*(zippo[1] + 1) == *(*(zippo + 1) + 1) // *(zippo + 1) == zippo [1]

*zippo         //zippo[0]
**zippo       //1
*zippo[0]    //1
```
2. 数组在内存中按序存储所以可以用相同类型的指针对数组进行按字节存储
```c
int pr = zippo;
pr+1;        //指向数组的[0][1] 元素
*(pr+1)=1; // == zippo[0][1] = 1; 
```

### 10.9 行指针

1. 使用二维数组的行地址即数组名初始化  
```c
int zippo [2][2];
int (*prz)[2] = zippo;  //　＆int prz[][2];两种效果一样编译器会将最左边的[]转换为指针形式,但是编译器会忽略其中的值
```
通过指针`prz`引用二维数组中的值有如下`4`种方法   
```c
1. prz[i][j];
2. *(prz + i)[j];
3. *(prz[i] + j);
4. *(*(prz + i) + j);
```

### 10.10 指向指针的指针/二级指针

```c
char ** pptr;
char *sptr;
pptr = sptr;  //一级指针指向一个char类型的指针
*pptr = "a"; //二级指针指向一个字符串字面量"a" == sptr = "a"
```


### 10.11 指针的兼容性

- 指针之间的赋值类型检查比较严格
    - 不能将不同类型的两个指针相互赋值
    ```c
    int * pt;        //指向int的指针
    int  (*pa)[3];  //int pa[][3]; 指向三个int元素的行指针
    int ar1 [2][3];//含有两个数组, 每个数组各有两个int元素
    int ar2 [3][2];
    int ** p2;   //指向指针的指针

    pt = &ar1[0][0];            //都是指向int的指针
    pt = ar1[0];               //都是指向int的指针
    pt = ar1;                 //二维数组名是一个行指针     无效
    pa = ar1;                //都是行指针
    pa = ar2;               //ar2含有两个int的行指针,pa含有３int的行指针    无效
    p2 = &pt;              //两个都是指向int 的指针
    *p2 = ar2[0];         //都是指向int的指针
    p2 = ar2;            //                                无效
    ```

- 指针使用需要注意  
    * 标准规定通过非`const`限定指针修改`const`限定数据结果将是未定义的  

```c
int x = 20;
const int y = 23;
int * p1 = &x;
const int * p2 = &y;
const int ** pp2;
p1 = p2;          //不安全 const指针赋值给非const指针时，将可以使用p1修改p2中的值
p2 = p1;         //有效，一级解引用，非const指针赋值给const指针
pp2 = &p1;      //不安全,嵌套指针类型赋值

===
const int ** pp2;
int *p1;
const int n = 13;
pp2 = &p1;      //允许，但是const限制符失效，可以通过*pp2修改指向--一级
*pp2 = &n;     //有效, 两者都是const类型,但是将导致p1指向n--二级
*p1 = 10;     //有效，但是这种行为是未定义的
```

### 10.12 处理二维数组的函数

- 函数声明：声明一个指向`N`个数组的行指针只能省略最左边的方括号的值  
    - 下面的声明等价:  
    ```c
    void sum_rows ( int (*ar)[COLS], int rows);
    void sum_rows ( int ar[][COLS], int rows);
    //错误的声明:void sum_rows (int ar[][], int rows);  //不能将列维度省略，编译器无法知道数组的大小
    ```

* 两种声明的区别是告诉函数将使用那种方法传递参数

```c
#define ROWS 3
#define COLS 4

int junk [3][4] = { { 2, 4, 6, 8 }, { 3, 5, 6, 9 }, { 12, 10, 8, 6 } };

// 函数调用
sum_rows (junk, ROWS);

// 函数定义
void sum_rows (int ar[][COLS], int rows){

  int tot;
  int r,c;

for (r = 0; r <= ROWS; r++){   //每行的和
   tot = 0;
   for (c = 0; c < COLS; c++)
     tot += ar[r][c];
   printf("rows = %d: sum = %d\n", r)
  }
}
```
### 2020-07-07加
> 二维数组传参  
```c
#define LEN 2
void arr(int ar[][LEN], int ** ar2, int len);

main (){
  int ar[][LEN] = {1, 2, 3, 4}, ar2[LEN][LEN] = {0};
  arr(ar, ar2, LEN);
}

void arr(int ar[][LEN], int **ar2, int len){
  for (int i = 0; i< len; i++)
    for (int j = 0; j < len; j++)
      *((int *)ar2+i*len+j) = ar[i][j];
}
```

### 10.13 `VLA`变长数组( `c99` )

- `c99`新增`VLA`,允许使用变量来表示数组的维度大小  
    - 变长数组并不是可以随意改变长度的数组  
    * 这样的数组有一些限制，变长数组必须是自动储存类别  
    * 无论在函数中还是作为函数形参声明都不能使用`static`或`extern`储存类别说明符,且不能在声明中初始化数组  
    * 一旦创建了变长数组，它的大小则保持不变，只是在创建数组时,可以使用变量指定数组的维度  

    ```c
    int quarters = 4;
    int regions = 5;
    double sales [regions][quarters];
    ```

- `c99/c11`规定可以省略函数原型中`VLA` 的形参名，但在这种情况下必须用星号来代替省略的维度  
`int sum2d (int, int, int ar[*][*]); //在函数中使用VLA`  

```c
const int SZ = 80;
double ar [SZ]; //是否可以？
```
- `c90` 可能允许  
- `c99/c11`允许,但是数组必须是声明在块中的自动储存类别数组  

- 变长数组还允许动态内存分配，这说明可以在程序运行时指定数组的大小，  
- 普通的`c`数组都是静态内存分配，在编译时就确定了数组的大小  


### 10.14 数组常量 复合字面量

1. `(类型名　[]){数值列表};`  
    - 复合字面量是匿名的，所以不能先创建它再使用,必须在创建的同时使用它  
    - 使用复合字面量的好处是在把信息传入函数之前不用创建数组  
    - 复合字面量具有块作用域  

- 假设给函数传递一个`int`类型的值,它可以是`int` 类型的变量也可以是`int` 类型的常量  
- `c99`新增了复合字面量，类似 `5`是`int`的复合字面量  
- `c99`的委员会认为如果有代表数组和结构内容的复合字面量在编程时会更加方便  

2. 普通数组声明  
```c
int ar[2] = { 2, 3 };
//复合字面量数组, 一样可以省略[]中的数值，编译器会进行自动填充
(int [2]) { 2, 3 };
```
3. 使用:
```c
int * pr;
pr = (int [2]){ 2, 3 }; //(int [2])本身就是首元素的地址

*pr; //2, pr指向首地址,解引得出值
*(pr + 1); //3
```
### 10.15 在处理一个基本类型时如何选择在函数中传参时选择指针还是实参

- 通常在不需要改变主调函数中的值时，我们选择直接传递数值，如果需要改变数值，则通过指针操作  
- 对于数组则没有选择，我们必须要传递指针，因为指针的效率更高，节省更多资源  


## 第十一章: 字符串处理 [返回顶部](https://github.com/GitNoWen/gitnowen/blob/master/arch_work/c/c-primer-plus/note.md#c-primer-plus---%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95)

> 字符串  
> C字符串函数库  
```c
gets(), get_s(), fgets(), puts(), fputs(), strcat(), strncat()
strcmp(), strncmp(), strcpy(), strncpy(), sprintf(), strchr()
```
### 11.1 `'\0', '0', 0, NULL` 的区别

- 从最本质上来理解这四种都表示了一个八位的`char`类型
    > `0`    :它可以表示任意类型的`0`值, 每一位都是`0`  

    > `'0'`  :字符`0`,在`ASCLL`中的编码是`48`  

    > `'\0'` :空字符,在`ASCLL`中编码为`0`,相当于一个`NULL`常量,占一个字节,对应`int`类型  

    > `NULL` :空指针,表示空,指针没有指向任何对象,对应的是指针类型,占`4`个字节  

* 在`ASCLL`中有一个代表`NULL`的字符,与计算机中的`NULL`宏意义不同,但是它们值都为`0`  
* 在`c`里,`0、0L和( void* )0`还有其它产生值`0`的整数常量表达式都是空指针常量  
* 空指针有一个值，不与任何有效内存地址对应，通常用来代表函数出现特殊情况  
* 相同之处是他们都可以用`0`来表示,但是在概念上他们是不同类型的`0`   


### 11.2 字符串常量(字符串字面量)

* 用双引号括起来的内容被视为指向该字符串储存位置的指针,类似一个数组  
* 字符串常量被储存在常量区,在函数中使用该字符串,该字符串只会被储存一次,在整个程序声明周期存在  
* 在程序中编译器将多次出现的相同的字符串字面量，储存在一处或多处  
* 使用`""`声明一个字符串常量  
* `""` 所做的事情
    1. 在内存常量区中申请空间存放字符串
    2. 在字符串末尾加`\0`
    3. 返回字符串首地址

```c
#define CHS "abcd"
printf("%s\n", CHS + 1); // 结果为bcd , 字符串指针指向该字符的下一个地址
```
- `ANSI c` 开始如果两个字符串中间没有间隔将视为一个字符串  
- `"a""b" == "ab"`, `"A" "B"`中间有空格做间隔表示两个字符串  

- `"abcd" // 对这个字符串进行解引得到该特殊数组的首元素的值a`

* 对于处理字符串数组形式和指针形式有何不同  
    1. 数组：  
        - 由于数组在程序运行时才会分配内存，每个字符串元素对应一个数组元素，并自动加上`\0`空字符,  
          而字符串字面量是储存在静态储存区，也就是当程序被载入内存中时也就载入了字符串,  
          然后在程序运行后给数组分配空间后再将字符串拷贝到数组中，也就是字符串有两个副本,  
          并且可以修改数组中字符串的副本，除非声明一个`const`数组  

    2. 副本：
        1. 静态储存区中的原字符串　  
        2. 数组中拷贝的字符串  

    3. 指针：
        - 字符串为`const` 类型所以指针也应声明为指向`const`的指针  
        - 否则使用指针去修改字符串字面量将会出现未定义的一些结果  

        - 将指针指向字符串，编译器会为字符串在静态存储区预留空间，  
        - 但程序开始执行程序会为指针分配一个存储位置并把字符串首元素的地址存储到指针中  
        - 可以使用递增递减来偏移地址, 但是const限定不能改变字符串的值  

- 当需要指向多个字符串时使用　指针数组
```c
const char * pchars[]{  //区分行指针　const char (* pr)[2];

  "多个字符串",
  "使用指针数组"
};              //相对字符串数组更加节省空间
```

* 指针数组的优点是：  
    1. 指针只储存了字符串的地址，操作更加简单,通常只有指针操作才能进行递增递减,但是不能修改字符串的内容  
    2. 普通数组的优势在于它可以修改字符串的内容  
    3. 在有多个字符串时使用指针数组的效率要高于数组  
    4. 用二维数组储存多个字符串时，列元素大小将由最长的一条字符串决定,所以并不是所有的内存位都有使用  
    ```c
    char chars[][5]={ //预留一个位放\0
      "ab",
      "abcd",
      "abc"
    };
    ```  
    5. 而指针数组指向多个在静态内存中的多个不连续内存段,不会有空余的内存,高内存利用率  


### 11.3 读取字符串输入

* `c99`以上的版本不建议再使用`gets` 函数
    - `gets`　在输入时不会检查输入的字符串是否溢出

1. `fgets`  
    - `c11`中`fgets()`函数可以作为`gets`的替代  
    - `fgets(chars, n, stdin);`  
    - 第二个参数是限定输入字符的数量`n`,而实际能读取的字符数为`n-1`, 留出一位是放`\0`空字符  
    - 第三个参数指明从何处读取输入，键盘输入为 `stdin`  
    - 何时停止读取
        - 1. 提前遇到换行符,将换行符存入字符串
        - 2. 当读取到n-1个字符,末尾自动加`\0`
        - 3. 当提前读取到文件结尾

* 和`fgets`配合使用`fputs`或`puts`  
```c
int puts (const cahr *);
int fputs(const char *,FILE *);  //第二个参数指定输出的位置,屏幕是stdout
```

- `puts`和`fputs` 主要的区别在于`puts` 会在末尾添加一个`\n`  

* `fgets` 的返回值  
    - `fgets` 函数返回一个指向`char` 的指针，如果一切顺利该函数返回的地址和传入的第一个参数相同，  
    - 如果它读到文件结尾，将返回一个空指针，该指针保证不会指向任何有效数据，在代码中可以用`0`代替或`NULL`  
    - 当读入数据出现错误时也会返回一个`NULL`  
    - 后面的学习中可以用feof 和 ferror 来判断是遇到结尾还是出错

2. 当要处理较长的字符串输入时, 使用`while`循环循环读取缓存区的字符串
```c
while (fgets (words, NUM, stdin) != NULL && words [0] != '\n');
  fputs (words, stdout);
```

3. 可选  
    - `c11`新增的函数`gets_s()` 用法与`fgets`差不多，它有两个参数,只从标准输入中读取输入  
    - `gets_s(words, NUM);   //第二个参数用来限制读取的数量`  

    - 它与`fgets` 的区别在于碰到`\n`换行符丢弃它而不是储存  
    - 它只从标准输入读取输入  
    - 如果`gets_s`读取到最大字符数未读取到`\n`会首先把目标数组中的首字符设置为空字符，  
    - 读取并丢弃随后的输入直至结尾或读取到`\n`，然后返回空指针，接着调用依赖实现的处理函数(或你选择的其他函数)可能会终止或退出程序  
    - 所以使用`gets_s`函数需要自己编写处理函数  

* 对比当输入超过可储存的字符时，`fgets()`最容易使用，所以当输入和预期不符合时`fgets`比`gets_s`方便  

4. `fgets`与`scanf`对比  
    - scanf用%s来读取字符串,从第一个非空白字符开始到写一个空白字符结束，但不会将空字符保存到字符串中

5. 根据这些条件对比在输入字符串，`fgets`函数比`scanf` 更加合适

- 使用`fgets()`创建一个自定义的输入函数  
```c
char * s_gets (char * st, int n) {

  char * ret_val;
  int i = 0;

  ret_val = fgets (st, n, stdin);
  if (ret_val){

    while (st [i] != '\n' && st [i] != '\0')
      i++;
    if (st [i] == '\n') st [i] == '\0';
    else
      while (getchar () != '\n')
        continue;
  }
  return ret_val;
}
```
### 11.4 字符串输出

`fputs, puts, printf`  
- 如果不想使用`c标准库`的函数,或想达到其他的要求  
- 可以在`putchar()`,`getchar()`两个函数的基础上添加自定义的函数  

- 需要一个类似`puts`但不会自动添加换行符  
```c
#include <stdio.h>
void s_puts(const char * string){ //const限定保证了指针不会修改字符串的内容
  while (*string) //一种普遍的测试方法，当string返回一个空字符\0时*解引用得0
    putchar(*string++); //* 解引符比++优先级别高
}
```

### 11.5 C处理字符串的头文件`string.h`  

- 其中最常用的有　`strlen(), strcat(), strcmp(), strncmp(), strcpy(), strncpy()`  
- 还有一个包括在`stdio.h`中的`sprintf()`  

1. `strcat()`和`strncat()`将两个字符串拼接返回第一个字符串首地址
---

    1. 第二个字符串的备份附加到第一个字符串的末尾，将拼接后的字符串替换第一个字符串,第二个字符串不变  

    2. 但是`strcat` 无法检测第一个字符串能否容纳拼接后的字符串和`\0`,  

    3. 如果空间不够则可能会造成溢出  
```c
  strcat(words1, words2);
  //前提是words1能够存放两个字符串所有内容并且能储存\0结束符
```

` strncat(words1, words2, 5);`
    1. 与`strcat`用法差不多，多了第三个参数，用来限制附加到第一个字符串后面的字符数  
    2. 当附加到第一个字符串的字符数到达NUM的值或者遇到空字符\0时停止附加  
        `strncat (words, addon, NUM);  //这样有效防止第一个字符串出现溢出现象`
- 注意  
 第一个字符串要能储存strlen(words) + strlen(addon) + 1 个字符,(strlen 不计算\0)  
 因为无论何种情况都要在字符串结尾加空字符\0  

2. `strcmp` 和 `strncmp` 将用户响应的字符串和已储存的字符串作比较 (不是比较单个字符)
---

 1. `strcmp`  
    1. `strcmp` 和 `strncmp` 根据字符的机器排序决定排序大小  
    2. 比较的对象还包括了`\0`结束符  

- `strcmp (input, "abc");`  
> 对比两个字符串直到发现第一对不同字符为止  
> 返回值  
> > 如果相同则返回`0`否则返回`非0`   
> > 若两个字符串开始相同后面不同，`strcmp`会依次比较每个字符直到发现第一对不同的字符为止  

```c
  strcmp ("Z", "a") = -1
  strcmp ("A", "A") = 0
  strcmp ("A", "B") = -1
  strcmp ("B", "A") = 1
  strcmp ("C", "A") = 2              //具体返回差值还是其他正数由不同的实现决定
  strcmp ("apple", "apples") = 115  //空字符在ascll中排第一所以s在它后面
```

2. `strncmp`  
    -  指定比较到第`5`个字符  
```c 
strncmp (input, "words", 5) //以words开头的都为匹配成功  
```
> 返回值  
> > 根据`ascll`标准规定  
> > 字母表中如果`字符串１`在`字符串２`前面返回负数  
> > 两字符串相同返回`0`  
> > 如果`字符串１`在`字符串２`后面返回正数  

3. `strcpy` 和 `strncpy` 拷贝字符串，相当于拷贝字符串的赋值运算符  
---

1. ` strcpy (words[i], temp);`  
  1. 用`strcpy`拷贝字符串时第一个参数容器一定要初始化，不然字符串可能会被拷贝到其他任意地方去    
  2. 第一个参数不必指向数组的开始，可以将字符串拷贝到数组的某一部分  
      `srecpy (words[i] + 3, temp);  //从第一个字符串的第二个字符之后开始拷贝第二个字符串(下标从0,1,2第三个元素)`  
> 返回值  
> > 返回值的类型为`char *` ,返回的是第一个参数的值,`&words[i]`中的值,如果是指针就是指针指向的地址  

2. ` strncpy (words[i], temp, n);`  
  1. `strncpy` 和`strcpy`都不会检查第一个参数能否容纳两个字符串  
  2. `strncpy` 和`strncpy` 用法一样 ,第三个参数可以限制拷贝的最大字符数,所以`strncpy`更加安全  
  3. `strncpy` 把`temp`中`n`个字符或空字符之前的字符拷贝到`words[i]`中,如果`temp`超过`n`个字符,则需要设置拷贝到`n-1`个字符停止  
  ```c
  strncpy (words[i], temp, n - 1);
  words [i][n] = '\0';  //然后手动将最后一位设置为空字符
  ```

4. `sprintf` 其声明在`stdio.h`中,和`printf()`函数类似，但是它是将字符串写入到容器中，而不是将其打印到屏幕上
---

1. `sprintf`按格式字符串将多个字符串合成一个,然后储存在目标容器  
    - 保证容器有足够的空间储存合成后的字符串  
    `sprintf(目标容器的地址,"%s, %-10s, %4s \n", "其用格式字符串", "控制储存的字符串的格式", "类似strcat")`

### 11.6 `string.h` 中一些常用的字符串处理函数

#### 1. `strchr`

        1. `char * strchr (const char *str, int ch);`  
        > 在`str`字符串中查找字符ch`   
        > 返回指向str中首次出现ch字符的指针,也就是该指针指向该字符的地址，否则返回`NULL`  
        `cahr * cptr = "hello";`  
        `*(cptr + 4) == 'o' == *strchr (cptr, 'o'); //strchr 返回指向'o'字符地址的指针`  

#### 2. `strpbrk`

        - `str`中包含`str2`中的任意字符，返回指向`str`首位置的指针，否则返回`NULL`    
        `char * strpbrk (const char *str, const cahr * str2);`  

#### 3. `strrchr`

        - 返回`str`中最后一次出现`ch`字符的位置，否则返回`NULL`    
        `char *strrchr(const char *str, int ch);`  

#### 4. `strstr`

        - 返回字符串`str`中`str2`字符串出现的最后一次，否则返回`NULL`   
        `char * strstr (const char * str, const char * str2);`

#### 5. `strlen`

        - 返回`str`中的字符数，不计入`\0`   
        `size_t strlen (const char * str);`

### 11.7 main中的参数  

- `main` 中的参数列表  
    - `int main (int argc, char **argv) // int main (int argc, char *argv[]) //char **argv == char *argv[]`  
    - 第一个参数计算运行程序添加的参数的字符串个数  
    - 第二个用来储存输入的参数字符串,通常`argv[0]` 用来储存程序名  
    - 就跟普通函数中的参数一样的用法  

### 11.8 `stdlib.h` 中用于字符串中的数值类型转换的函数

1. 字符串类型数值转换为`int`类型数值  
```c
  char *chars = "12";
  atoi(chars);          //返回int类型12，

  chars = "abc";
  atoi (chars);      //返回0,c标准规定这是未定义的行为, 如果参数是字符字符串则返回0

  atoi("42chars"); // 返回42, 如果是以数值开头的字符串则返回开头的整数
```

2. 字符串类型数值转换为`double`类型  
    - `double atof (cahr*);`

3. 字符串类型数值转换为`long`类型  
    - `long atol (char*);`

4. 字符串类型数值转换为`long` 和 `double` 类型，识别和报告字符串是否数字开头,并且指定数字的进制
    ```c
    //strtol 函数最大支持36进制的转换
    long strtol (const char * restrict ntpr, char ** restrict endptr, int base);
      //nptr 指向待转换字符串,
     //endptr 指针地址表示数字结束符的位置，
    //base 表示以什么进制写入数字
    ```

5. 专门用于将字符串类型数值转换为`10进制`数字,所以只需要两个参数    
    - `double strtod (const char * restrict nptr, char ** restrict endptr);`

6. 转换为无符号值  
    - `unsigned long strtoul (const char * restrict nptr, const char ** restrict enptr, int base);`  

> 将整数和浮点数转换为字符串的函数, 但是这两个函数并不属于标准的`C函数库`  
  `itoa ()` 整数转换为字符串  
  `ftoa ()` 浮点数转换为字符串  
  代替的函数是使用fprintf()　函数，且兼容性更好  


## 第十二章: 存储类型 [返回顶部](https://github.com/GitNoWen/gitnowen/blob/master/arch_work/c/c-primer-plus/note.md#c-primer-plus---%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95)  
> 关键字: `auto, extern, static, register, const, volatile, restrict, _Thtrad_local, _Atomic`
> 函数  : `rand (), srand(), time (), malloc(), calloc (), free ()`
> 作用域，生命周期

### 12.1 储存类别

> C 语言中对对象的定义: 
> > 从硬件来看，被储存的每个值都占用一定的物理内存，这样的一块内存称之为对象  

> 面向对象编程中对象的定义:  
> > 指的是类对象，其定义包括数据和允许对对象进行的操作  

1. 对象  
    1. `ptr`是一个标识符，它指定了一个储存地址的对象(储存`ch`标识符地址的内存, `ch`中储存了`'c'`的地址)  
    * 但是表达式`(*chpr)` 不是一个标识符，但是它也指向了一个对象(储存`'c'`的那块内存),它与`ch`指向的对象相同,    
    * 一般指向对象的表达式称为左值, 变量名是标识符也是一个可修改的左值  
```c
char ch = 'c';         //ch 是内存中储存'c'这块内存的标识符, ch 指向了该对象
char * ptr = &ch;     //指向该对象不一定要是标识符,也可以是一个指针, 有多种指向对象的途径
```

2. 存储期，作用域，链接  

> 1. 储存期：  
> > 指对象保留的时间   

> 2. 作用域和链接：  
> > 用于描述标识符在程序的哪些部分可以使用

### 12.2 作用域

- 指变量在程序结构中的可见范围
    - `c99`之前要求具有作用域的变量必须声明在块的开头,
    - `c99`之后的标准放宽了限制，允许可以在块中的任意位置声明变量

1. 作用域有：

> 1. 块作用域 :
      - 用花括号括起来的代码区域
      - `while, for, if, do while` 即使它们的循环体没有被花括号括起来但它们都具有块作用域

> 2. 函数作用域 :  
      - 仅限于`goto`语句标签

> 3. 函数原型作用域 :   
      - 用于函数原型中的形参名,范围从形参定义处到原型声明结束

> 4. 文件作用域(全局作用域/外部链接文件作用域)：  
      - 对一个或多个翻译单元可见的作用域  

* 具有内部链接的变量的文件作用域只对一个翻译单元可见

### 12.3 翻译单元和文件

- 编译器将源代码文件和头文件都看成是一个包含信息的单独文件，这个文件被称为`翻译单元`
如果程序有多个源码文件，就会有多个`翻译单元`

### 12.4 链接

- 术语描述:  
    1. 内部链接的文件作用域,仅限于一个翻译单元的作用域可见 有些程序员称为文件作用域:  
        - 如何创建一个具有内部链接的文件作用域变量  
        - 在函数外使用`static`标识的文件作用域变量具有内部链接，只对当前翻译单元可见  
        - `static int n = 1; //n 只对当前文件可见`  

    2. 外部链接的文件作用域,表示变量的作用域对多个翻译单元可见 有些程序员将这种作用域称为全局作用域:  
        - 在函数外创建未加`static` 限定的变量为全局变量  
        - 具有外部链接的变量可以在其他的翻译单元中用`extern`引用  

    2. C语言变量具有作用域相关的三种属性链接:  
        1. 外部链接:具有外部链接文件作用域的变量对多个编译单元可见  
        2. 内部链接:具有内部链接文件作用域的变量只对当前翻译单元可见  
        3. 无链接  :具有块作用域，函数作用域或函数原型作用域的都是无链接  

### 12.5 储存期

- 储存期描述了通过这些标识符访问的对象的生存期  
    - c 语言对象具有`４`种生存期  
        1. 静态存储期 `static`  
           具有静态存储期的对象，在程序的执行期间一直存在  
           文件作用域变量无论是外部链接还是内部链接都具有静态存储期  
           对于具有文件作用域变量 `static` 表明了它的链接属性而非存储期  
           如果是在函数块中定义的`static`静态变量,函数在下次调用时保留静态变量的值  

        2. 线程存储期 `_Thread_local`  
           线程存储期用于多线程并发编程  
           具有线程存储期的变量在线程结束前都存在  
           `_Thread_local int a; //线程局部存储`  
           每个线程都获得该变量的私有备份  

        3. 自动存储期　`auto`：自动分配内存和自动释放内存  
           通常块内声明的变量都是自动存储期变量，并且省略关键字`auto`  
           块作用域通常具有自动存储期(块作用域具有无链接的特性)  
           在程序进入块中时，为自动存储期的变量分配内存, 在退出块时释放为变量分配的内存  
        *  但是有一个例外,`VAL`变长数组的存储期并不是从块开始一直到块结束而是从`VAL`的声明处一直到块结束  

        4. 动态分配存储期
           使用函数分配内存的变量具有动态存储期  
           例如 `malloc, calloc` 等
           通常这种变量，存储期是整个程序的声明周期，所以需要使用`free()`函数将内存释放

### 12.6 内存中的存储区域

> 栈：存储自动变量
> 堆：由`malloc`这类函数分配的内存块，需要手动`free`
> 全局/静态：全局和静态变量存储的区域
> 常量     ：常量存储


### 12.7 `5`种存储类别

> --类别       存储期　  作用域　    链接　    声明方式  

> > 自动       自动　　　块内　　　　无链接　　块内声明 //一般的变量都属于自动类别  
> > 寄存器　 　自动　　　块内　    　无链接　  块内　　//使用register 声明一个寄存器类别变量  
> > 静态外部　 静态　  　所有文件　　外部　　　函数外　  
> > 静态内部   静态　　　单个文件　　内部　　　函数外//使用static　  
> > 静态无链接 静态　　　块内　　　　无　　　　块内 //使用static  


### 12.8 自动变量

- 默认情况下，声明在块中和函数头中的变量都属于自动存储类别  
  自动变量不会自动进行初始化除非进行显示的初始化赋值  
  ```c
  int b;      //b标识的对象中的值是未定义的
  int a = 1; //显示初始化
  ```

- 显示的将变量设置为自动存储类别  
    - 一般的情况只是为了表明有意覆盖一个外部变量或强调不要改变该变量的存储类别  
      `auto`关键字与`c++`中的`auto` 不兼容，所以在编写与`c++`兼容的程序时不要使用`auto`
`auto int a;`

### 12.9 嵌套块

- 在嵌套块中的变量仅限在块中使用  
```c
int loop (int n){    // n　作用域是整个块

  int m;           //m 的作用域在整个块中
  scanf ("%d", &m);

  {    //嵌套块开始
 
    int i;    //嵌套块中的变量
    for (i = m; i < n; i++)    // i的作用域仅限在声明块中
      puts ("i is local to a sub-block\n");
  }//块结束

  return m;
}
```
* 当内层块中的变量名和外层变量名相同时，内层块会将外层块隐藏，在离开内层块恢复外层块同名变量的作用  
* 在循环中的同名变量的作用域  
```c
int x = 2;
while (x++ < 10){ //测试使用的为外部的x,递增外部x

  int x = 7;    //每次进入块中都会创建x,进入内部后隐藏外部x
  x++;         //内部x递增
  //内部的x作用域到此处结束,所以下一轮while测试的为外部的x
}
```
* 有些编译器会新创建一个`x`，但是有些编译器会复用外部`x`的内存, 所以并不推荐这样编写程序

### 12.10 没有花括号的块

- `if` 或 `循环`,即使没有花括号，也是一个块　//`c99`的新特性

### 12.11 寄存器变量

* 由于`cpu寄存器`的数量是有限的,所以使用`register` 声明一个变量更象是发出一个请求，
  编译器根据可用的寄存器来选择是否忽略请求
* 如果没有可用的寄存器，则寄存器变量变为普通变量，但是仍然无法获取该变量的内存地址  
* 并且不是所有的数据类型都可以请求寄存器储存，理由是寄存器的数量可能不够  

* 寄存器变量储存在`cpu寄存器`中，相对于普通变量访问和处理这些数据的速度更快
* 寄存器变量由于储存在`cpu寄存器`中使用无法获取其变量地址

### 12.12 静态变量

- 在块中用`static`声明的局部变量,具有以下特性  
> > 块作用域  
> > 无链接  
> > 全局生命周期   
- 如果没有对`static`静态变量进行显示初始化,编译器将默认初始化为`0`

### 12.13 外部链接的静态变量

- 如果在一个源文件中声明了一个外部具有文件作用域的变量  
  可以在函数中使用`extern`再次在函数中声明要使用一个具有文件作用域的全局变量

* 如果全局变量和使用变量的源文件不是同一文件，则必须使用`extern`再次声明变量  
```c
extern char Coal;   //在另一个文件中定义的全局变量

int Errupt;       //外部定义的全局变量
double Up [100]; //外部定义的数组

void next (void);          // 声明一个文件作用域的函数
int main (void){

  extern int Errupt;    //可选声明，可以完全省略因为在同一源文件中
  extern double Up[];  //可选
}

void next (void){

  extern char Coal;
  static int a;   //声明一个函数内的静态变量,next 的私有变量
}
```

### 12.14 初始化外部全局变量需要注意的

- 外部变量和自动变量类似，可以被显示初始化  
- 外部变量如果未被显示初始化则初始化为0，此规则适用于外部数组  
- 与自动变量不同的是  
    - 只能用常量表达式初始化文件作用域变量，不能使用变量  
```c
int x = 10;        //ok
int y = 3 + 20;   //ok
size_t z = sizeof (int); //ok
int x2 = 2 * x; //不可以　x是变量
//(只要不是变长数组，sizeof 可被视为常量表达式)
```

### 12.15 外部变量

- `c99` 和 `c11` 规定要求编译器要识别 局部标识符的前`63`个字符和外部标识符的前`31`个字符

- 以前的标准规定编译器只识别局部变量的前`31`个字符和外部变量的前`6`个字符  

### 12.16 定义和声明

- `extern` : 表示告诉编译器该关键字的声明不是定义，要去其他的地方查询定义

1. 外部变量第一次声明称为 : 定义式声明
2. 使用`extern` 再次声明称为: 引用式声明

### 12.17 内部链接的静态变量

- 用`static`声明一个具有 
    1. 内部链接
    2. 静态存储期
    3. 文件作用域的变量
    ```c
    static int a;
    int main (void){}
    ```
- 也可以使用`extern` 进行重复声明来强调要使用一个具有内部链接的静态变量

## 12.18 存储说明符

- C语言拥有`6`种存储类型说明符
    1. `auto`  
        - 块作用域的变量都具有自动存储类型的特性，加上`auto`说明符是为了强调编译器区别同名的外部变量  

    2. `register`  
        - 只用于具有块作用域的变量,并可以保护变量的地址不会被获取到  

    3. `static`  
        - 静态变量说明符,在程序载入内存时就会为变量创建对象,但是只有在块内的代码才能通过标识符访问该变量  

    4. `_Threah_local`  
        - 并行存储说明符,可以与`static` 和`extern` 一起使用

    5. `extern`  
        - 表明变量或函数的定义在其他地方  

    6. `typedef`   
        * `teypedef`关键字和任何内存存储无关  
        * 将`typedef`归类于存储类型说明符有一部分原因是语法  
        * 除`_Threah_local` 能和`static`和`extern`一起使用外，在声明中不能使用多个存储类型说明符  
        * `typedef`不能和多个存储类型说明符一起使用  

### 12.19 函数和储存类别

- 函数也具有存储类别
    - 外部函数
    - 内部函数
    - 内联函数(`c99`)

- 用`static`声明一个内部函数,只允许当前声明的文件使用  
  函数除非声明为`static`内部函数,否则一般默认为`extern`

### 12.20 存储类别中的陷井

- 大量的使用外部变量，可能函数会不经意更改变量的值，而程序员没有察觉到    
  所以使用存储类别的规则是`按需使用`  

### 12.21 随机函数，静态变量

- `ANSL C`提供`rand()`函数生成伪随机数,生成的是可以预测的数字实际数列  
  `rand()`生成的伪随机数在`0~RAND_MAX`之间，`RAND_MAX`定义在`stdlib.h`中，通常为`INT_MAX`  

- 可移植的伪随机数算法  
    - 利用一个种子为基础生成新的值再进行生成  
`static unsigned long int num = 1;   //种子`

### 12.22 `time.h` 访问系统的时钟

```c
#include <time.h>
sreand1 ((unsigned int) time(0));   //用系统时钟来伪随机数初始化种子
```

- `time()` 返回系统时间,该返回值是一个可以运算的类型，类型名为`time_t`  

- `time()` 接受的参数是一个`time_t`类型对象的地址，时间值存储在传入的地址上  
   也可以将`空指针(NULL)`作为参数，只通过返回机制来提供值

### 12.23 分配内存 `malloc()` 和 `free()`

- 创建一个`double`数组
```c
double * dptr;
dptr = (double *) malloc ( 30 * sizeof (double)); //== double ptr[30];
//指针 dptr 被指向一个double类型，而不是一个30个double类型值的块
//该指针用法和数组名差不多
```

1. `malloc` 接受一个参数需要多少的内存字节数,自动找到合适的空闲块, 这样的内存是匿名的  
2. `malloc` 分配内存，但是不会为其赋名  
- 但是会返回这块内存的首地址，可以把该值赋给一个指针变量，使用指针访问这块内存  

* 旧的标准中 `char`表示`1`个字节，所以`malloc`的返回类型通常被定义为指向`char`的指针  
* 从`ANSL C`开始使用一个新的指针类型：指向 `void` 的指针,  
* 该类型的指针相当一个通用指针,将指向`void`的指针赋值给其他类型，完全不用考虑类型匹配规则  
* 可以被用于强制转换为其他类型的指针    

* `malloc` 分配内存失败
    - 失败返回一个空指针,在处理代码中调用`exit()`函数结束程序

### 12.24 目前为止创建数组的三种方法

1. 声明数组，用常量表达式表示维度，用数组名访问元素，可以用静态或动态内存创建它  

2. 变长数组`VAL`(`c99`)，用变量表达式表示维度，数组名访问元素，只能创建为自动内存  

3. 手动用`malloc`分配内存，将其返回值赋给指针，使用指针访问元素，可以是静态或动态  

* 使用`2`、`3`可以创建动态数组，在程序运行时改变数组大小
* `c99`之前不支持`VAL`但是可以用`malloc`手动创建一个动态数组
```c
int item[n];  //仅c99支持
int *pInt = (int *) malloc (n * sizeof (int));
```

### 12.25 `malloc()` 的配套函数 `free()`

- `free()`的参数是一个指向`malloc`分配的内存的地址的指针  
- 该函数释放`malloc`分配的内存  

* 不能用`free`释放通过声明分配的自动内存  
* 不能用释放同一块内存两次  

### 12.25 `exit()`

1. `exit()`函数的原型在`stdlib.h`中  
`viod exit(int status);`  

2. `exit` 用于结束程序，终止正在进行的进程  
> 返回值,一般返回给系统  
> > `0`  为正常结束程序  
> > `!0` 表示异常退出  

3. 一些操作系统还支持一些其他表示程序运行状态的整数值

4. 区别`return`  
> `return` 为关键字
> `exit()` 为操作系统提供或库中的函数

5. 可移植的`exit()`,定义在`stdlib.h`中的两个相关宏
```c
EXIT_FAILURE:表示程序异常结束
EXIT_SUCCESS:表示程序正常结束
```
* `ANSL C`标准规定，在最初调用的 `main`中使用`exit(0)`和使用`return 0`效果相同
* 但是如果`main`在一个递归程序中，不是最初的一次调用
* `exit` 仍然会结束程序，而`return` 则会将控制权返还给上一级调用，在最初一级的调用结束程序
* 还有一个不同，在其他函数中`exit`仍然会结束整个程序,`return`则将控制权和返回值, 返还给主调函数

### 12.26 动态分配内存 `calloc()`

1. 和`malloc()` 类似的分配内存的函数
```c
long * new;
new = (long *) calloc (30,sizeof (long));
```
2. `calloc()` 有两个参数
    1. 存储单元的数量
    2. 存储单元的大小(字节)

3. 同样使用`free()`释放分配的内存  

4. 与`malloc`不同，在于它将块中的所有位设置为`0(`有些系统并不是把所有位设置为`0`来表示浮点数)

### 12.27 动态内存分配和变长数组

1. `VAL`和`malloc`在功能上有些重合
```c
int n = 2;
int * pt;
pt = (int *) malloc (n * sizeof (int));
int ar[n];  //VAL
```
2. 不同之处在于 `VAL` 是自动类型，在离开函数后`VAL`会被自动释放  
3. 而`malloc `分配的内存可以为`static`类型指针或利用指针传址在别处使用,要手动`free`才能释放  

4. 动态多维数组创建
    - `VAL` 会相对便捷,但是局限于C协议标准,`c99+`
    - 创建一个动态二维数组
```c
int n = 5;
int m = 6;
//VAL 创建二维
int ar2 [n][m];
//用malloc 创建二维
int (* p2)[6]; //不支持c99
int (* p3) [m];//VAL
p2 = (int *) malloc (n * 6 * sizeof (int)); //不支持c99,n * 6固定维度的二维数组
p3 = (int *) malloc (n * m * sizeof (int)); //支持VAL
```

### 12.28 `ANSL C`中的限定类型符

- `c90` 增加 恒常性 `const` 和 易变性 `volarile` 关键字  
- `c99` 增加 `restrict` 用于提高编译器优化  
- `c11` 增加 `_Atomic` 在可选库`stdatomic.h`中，用于支持并发编程  

1. `c99` 为类型限定符增加了一个特殊的属性，`幂等`(`idempotent`)  
    - 可在一条声明中多次使用同一个限定符，多余的限定符将会被省略  
    - `const const const int i = 1; == const int i = 1;`  

2. 有了这个新属性可以编写类似  
```c
  typedef const int i;
  const i q = 8;
```

### 12.29 `volatile` 易变限定符

```c
volatile int locl;
volatile int * ploc;
```
1. `volatile` 告诉计算机，可以通过代理来改变该变量的值,警告编译器不要对其进行假定优化
2. 通常用于 硬件地址，在其他程序或同时运行的线程中的共享数据

3. `volatile` 被放入标准的主要原因是它涉及到编译器的优化
```c
val1 = x;
val2 = x;
```
4. 编译器会注意到，以上代码使用`x` 两次，未改变其值    
   于是将`x` 的值临时存储在寄存器中，当`val2`使用`x` 则从寄存器中而不是原始位置读取`x`   
   这样的好处是节约时间  

5. 整个过程被称为高速缓存，通常情况下是一个不错的优化方案  
   但是如果有代码在这两个赋值中间改变了x的值就不能这样优化了

### 12.29 同时使用`const` 和 `volatile`

- 通常将硬件时钟设置为`const`类型,这样就不会被程序更改了
- 但是`volatile` 限定使得它可以被代理改变
- 只能在一个声明中同时使用这两个限定,它们的顺序并不重要
```c
volatile const int loc;
const volatile * ploc;
```

### 12.30 `restrict`

- `restrict`限定允许编译器优化某部分代码更好支持计算，但是却有一些使用限制  
    1. 只能用于指针  
    2. 表明该指针是访问数据对象的唯一且初始的方式  
```c
int ar[10];
int * restrict rester = (int *******) malloc (10 * sizeof (int));
int * par = ar;
```
- 这里`rester` 是访问`malloc`分配内存的唯一且初始的方式，所以可以用`restrict`关键字限定它  
- 指针`par` 既不是访问`ar`中内存的唯一方式也不是初始方式,所以不用把它设置为`restrict`  

### 12.31 多线程并发限定`_Atomic` (`c11`)

- 并发编程  
- `c11`提供两个可选头文件：`stdatomic.h 和 threads.h`   

- 需要注意要通过各种宏函数来访问原子类型  
- 但一个线程对一个原子类型数据进行原子操作时，其他线程是不能访问该对象的


### 12.32 `static`的新特性

- `c99`允许把 `类型限定` 和 `存储期限定符 static` 放到函数原型和函数头的形式参数的初始化方括号中  
`void a(int n[static 20]); // 表明函数调用中参数应该是一个指向数组首元素的指针,且数组至少有 20 个元素`  
* 这样的目的是让编译器用这些信息来优化函数的编码
```c
//一种可替代语法
void ofmouth (int * const a1, int * restrict a2, int a); //旧式风格
void ofmouth (int a1[const], int a2[restrict], int a);  //c99开始支持的新风格
```
## 第十三章: 文件操作 [返回顶部](https://github.com/GitNoWen/gitnowen/blob/master/arch_work/c/c-primer-plus/note.md#c-primer-plus---%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95)  

> 文件输入/输出  

> 函数：  
> > `fopen  (), getc   (), putc (), exit  (), fclose()`  
> > `fprintf(), fscanf (), fgets(), fputs ()`  
> > `rewind (), fseek  (), ftell(), fflush()`  
> > `fgetpos(), fsetpos(), feof (), ferror()`  
> > `ungetc (), setvbuf(), fread(), fwrite()`  

### 13.1 文件

- `c程序`把文件看作是一连串连续的字节，每个字节都能被单独读取  
- `c语言`提供了两种文件模式:   
    > 1. 文本模式  
    > 2. 二进制模式  

### 13.2 文本模式，二进制模式

- 如果文件最初使用`二进制编码`的字符`(ASCLL/Unicode)`来表示文本，那么该文件就是`文本文件`，其中包含文本内容  
  如果文件中的`二进制编码`代表`机器语言`或`数值数据`或`图片`或`音乐编码`，该文件就是`二进制文件`，包含`二进制内容`  

> 1. `二进制模式`  
> > 程序可以访问文件的每一个字节  
> 2. 文件的`文本模式`  
> > 程序所见内容和文件的实际内容不同  

* `linux` 只有一种文件类型，所以这两种模式对`linux` 而言都相同

### 13.3 `i/o 处理级别`

- 除了选择文件的模式外，大多是情况下可以选择两种`i/o处理级别`(处理文件访问的两个级别)

> `底层i/o`，使用操作系统提供的`基本i/o服务`  

> `标准高级i/o`,使用`C函数库`定义的`标准i/o包`

* 因为无法保证所有计算机都使用相同的`底层i/o模型`，`C标准`只支持`标准i/o包`  
* 有些实现会提供底层库，但`C标准`建立了`可移植的i/o模型`  

### 13.4 标准i/o处理文件

- `C程序`会自动打开`3`个文件：
> 1. 标准输入(`stdin`)
> > 默认情况下，标准输入为系统的普通输入设备，通常是键盘

> 2. 标准输出 (`stdout`)
> > 通常是显示屏

> 3. 标准错误输出 (`stderr`)
> > 标准错误输出提供一个逻辑上不同的地方来发送错误信息

### 13.5 `标准i/o处理包`

- `标准i/o包`的一些特性
> 1. 具有`可移植`的特性  
> 2. 有许多函数来简化处理`i/o`问题  
> 3. 输入和输出都是`缓冲`的，一次性转移`一大块`信息而不是`一字节`信息(通常这个信息块为`512字节`)  


### 13.6 打开一个文件 `fopen ()`  

`FILE * fopen (const char *restrict __filename,const cahr *restrict __mode)`

- 1. 打开文件,它的`第一个参数是待打开的文件名`,更准确的说是包含一个文件名的字符串地址  
- 2. `第二个参数是一个字符串`,指定待打开文件的模式,有六种字符组成`r,w,a,b,+,t(一般省略)`  

1. 第二个参数支持的基本模式
    > r --读模式打开  
    > w --写模式打开,已存在将现有文件长度截为0(将现有文件的内容删除),如果文件不存在则创建一个新文件  
    > a --写模式打开,在现有文件的末尾添加内容，如果文件不存在则创建一个新文件  

2. 更新模式  
    > r+  --以更新模式打开文件(读写)  
    > w+  --以更新模式打开文件(读写),如果文件存在将其长度截断0(将现有文件的内容删除),不存在则创建一个新文件  
    > a+  --以更新模式打开文件(读写),在现有文件的末尾添加内容，如果文件不存在则创建一个新文件,可读整个文件，但是只能在末尾添加内容  

3. 二进制模式  
    - 与上一个模式类似，但是以二进制打开文件，而不是文件模式  
        - `rb, wb, ab, rb+, r+b, wb+, w+b, ab+, a+b`  

4. `x模式`(`c11`),如果`文件已存`在或`以独占模式打开文件`，则`打开文件失败`  
    - `wx, wbx, w+x, wb+x, w+bx`
- 与`非x的写模式`相比，在`打开失败`后`不会将源文件的内容删除`  
  且如果环境允许，`x模式`的`独占特性`使得其他程序或线程无法访问正被打开的文件  

* 如果用`非x的写模式`打开任意现有文件，则该文件的内容会被删除，以便程序在一个空白文件中开始操作  
* 使用`带x的模式`将无法打开一个现有文件

5. 返回值
> > 成功打开文件，返回文件指针
> > 打开失败返回一个空指针

### 13.7 `getc/putc`函数

`int getc (FILE *__tream);`  
`int putc (int __c, FILE *__tream);`  

- `getc()`返回值
    - 在读取到文件结尾时停止读取，返回`EOF(-1)`  
    ```c
    FILE *fp;
    fp = fopen ("a.txt", "r");
    while ( (ch = getc(fp)) != EOF){ //测试文件结尾

      putchar (ch);
    }
    ```

### 13.8 关闭文件`fclose () /c99`

`int fclose (FILE *__steam) `  
- 在文件被关闭时将缓冲区中的数据保存到文件中  
- 返回值  
> > 关闭文件成功返回`0`  
> > 如果关闭失败返回`EOF`  

- 一般出现失败这种情况是磁盘已满，移动硬盘被移除或者出现`i/o`错误，都会导致`fclose`调用失败  
  在程序结束时会自动对所有打开的文加调用`fclose`,但是由于在没有写入文件之前数据都是在缓冲区  
  所以可以养成操作一次关闭文件保存一次  

### 13.9 指向标准文件的指针

- `stdio.h`将三个文件指针和三个标准文件相关联

> > 标准输入     `stdin`
> > 标准输出     `stdout`
> > 标准错误输出 `stderr`

### `fgets/fputs`函数

`char *fgets (char *restrict __s, int __c, FILE *restrict __stream); //第一个参数为字符串存储位置，二是字符串的大小，三是获取输入的位置`  
`int fputs (const char *restrict __s, FILE *restrict __stream);`  

- 对比`fprintf/fscanf`
`int fprintf(FILE *restrict __stream, const char *restrict __format, const char *str); //和fgets 相反, 第三个参数可以没有`
`int fscanf (FILE *restrict __stream, const char *restrict __format, char *str); // 第三个参数可以没有`


### 13.10 移动文件指针的指向  

#### 1. `rewind()`  
        - `void rewind (FILE *__stream);`  
        - 指向到文件开始处  

#### 2. `fseek ()/ftell ()`    
- 移动到文件的任意字节处，将文件作为一个数组来处理    
    1. `int fseek (FILE *__stream, long __off, int __whence); //三个参数`    
        > 第一个参数：`FILE *` ,已经由`fopen`函数打开的文件    

        > 第二个参数：偏移量,一个`long`类型的值，正(当前位置前移), 负(当前位置后移), 0(保持不动)  

        > 第三个参数：确定当前偏移量的起始位置，在`stdio.h`头文件中定义了几个表示模式的明示常量  
        > 1. `SEEK_SET  文件开始处 //0L`  
        > 2. `SEEK_CUR  当前位置  // 1L`  
        > 3. `SEEK_END  文件末尾 //  2L --一些旧的实现可能缺少这些定义，可以用数值表示这三种模式`    

        - 返回`int`类型  
            - 如果一切正常 `fseek` 返回0  
            - 如果错误(试图移动的距离超过文件的范围),返回`-1`  

    2. `long ftell (FILE *__stream); //一个参数`  
        > 返回文件指针当前位置距离文件开始处的字节数,一个long类型的值  
        > 适合以二进制模式打开的文件,以文本模式打开的情况不同  

### 13.11 `fseek()`函数,二进制和文本模式

- 在`ms-dos`中 用`\r\n`表示换行，以文本模式打开这种文件时,`C程序`将`\r\n`看作`\n`,  
  而以二进制打开文件时`\r\n`都可以看见  

- `fseek ()`函数在文本模式和二进制模式的工作方式不同,
    - 许多系统的文本文件格式与unix的模型不同，所以导致从文件开始处统计的字节数变得毫无意义  
      `ANSI C` 规定对于文本模式，`ftell()`函数的返回值可以作为`fseek()`函数的第二个参数  
    - 在二进制模式中实现不必支持`SEEK_END` 模式，移植性更高的方法是逐字节读取整个文件直到文件末尾  
    - 在文件模式下 三种模式的行为可以得到保障


### 13.12 支持更大范围的 `fgetpos() / fsetpos()`函数

- `fseek/ftell` 最大的问题是，这两个函数将文件的大小限制在了`long类型`能表示的范围内

- `ANSI C` 新增了两个处理较大文件的定位函数
    - `fgetpos / fsetpos`
        - 返回`fpos_t`类型 (file position type 文件定位类型)
        - `fpos_t`类型的变量或数据对象可以在文加中指定一个位置，它不能是数组类型

    - `int fgetpos (FILE * restrict stream, fpos_t * restrict pos);`
        - `pos` 指向的值描述了文件中的当前位置距离文件开头的字节数
        - 成功返回`0`
        - 失败返回`!0`

    - `int fsetpos (FILE *stream, const fpos_t *pos);`
        - 用 `pos` 指向位置上的`fpos_t`类型值来设置 文件指针指向偏移该值后指定的位置
        - 成功返回`0`
        - 失败返回`!0`

### 13.13 `标准的i/o机理`

- `标准i/o`使用  
    - 调用`fopen()`打开文件  
        1. c程序会创建一个缓冲区(读写模式写创建两个缓冲区)以及一个包含文件和缓冲区数据的结构  
        2. `fopen` 会返回一个指向该结构的指针，称作`fopen`打开了一个流,文本模式就是文本流，二进制打开就是二进制流  
            - 这个结构通常包含  
            1. 一个指向流中当前位置的文件位置指示器  
            2. 一个错误指示器  
            3. 一个文件结尾指示器  
            4. 一个指向缓冲区开始的指针  
            5. 一个文件标识符  
            6. 一个计数器(统计实际拷贝进缓冲区的字节数)  

2. 调用一个定义在`stdio.h`中的输入函数  
    1. 调用这些函数时，文件中缓冲大小的数据块就会被拷贝到缓冲区中，缓冲区的大小一般是`512字节`或其倍数  
    2. 在填充缓冲区后将`fp`指向结构中的值，设置流中当前的位置和拷贝进缓冲区的字节数，通常当前位置从`字节0`开始  
    3. 在初始结构和缓冲区后，输入函数按要求在缓冲区中读取数据  
    4. 当读取上一个字节后将文件位置指示器设置为被读取字符的下一个字符  
    * `stdio.h`中的函数都使用相同的缓冲区所以调用的任何一个函数都会从上一次函数停止调用的位置开始  

3. 当输入函数读取完缓冲区的所有字符时，会请求将下一个缓冲大小的数据块填充到缓冲区中，以这种方法直到读取完整个文件  
   函数在读取完缓冲区最后一个字节后，结尾指示器就会被设置为真，于是下一次调用输入函数时会返回`EOF`  
-  输出函数以类似的方式将数据写入缓冲区，当缓冲区被填满，数据将被发送出去  

### 13.14 其他的一些`i/o函数`

1. `int ungetc (int c, FILE *fp)`  
    - int ungetc ()函数将指定的字符放回输入流中  
    - 下一次调用标准输入时将读取到该字符  

2. `int fflush (FILE *fp);`
    - 调用`fflush ()`函数将会引起输出缓冲区中所有的未写入数据被发送到`fp`指定的输出文件，这个过程被称为刷新缓冲区  
    - 在输入流中使用`fflush()`函数的效果是未定义的  
    - 只要最近一次操作不是输入操作，就可以使用该函数来更新流(任何读写模式)  

3. `int setvbuf (FILE * restrict fp, char * restrict buf, int mode, size_t size);`  
    - `setvbuf()`函数创建一个提供`标准i/o函数`替换使用的缓冲区  
    - 在打开文件后未对流进行其他操作之前，调用该函数  
        1. `fp`   指向待处理的流  
        2. `buf`  指向待使用的缓冲区：如果`buf`的值不是`NULL`则必须创建一个缓冲区，若将`NULL`作为值，该函数会为自己分配一个缓冲区  
        3. `size` 告诉`setvbuf`数组的大小  
        4. `mode` 三种模式：  
        ```c  
        _IOFBF 完全缓冲
        _IOLBF 行缓冲(缓冲区满或一个\n)
        _IONBF 无缓冲
        ```
        5. 返回值  
        > 成功返回`0`  
        > 失败返回`!0`  

        6. 假若一个程序要储存一个数据对象，每个数据对象大小为`3000字节`，使用`setvbuf`创建的缓冲区大小为该数据对象大小的倍数  


4. 二进制`i/o`函数：`fread() / fwirte()`  
    - 前面的`标准i/o函数`都是面向文本的，用于处理字符和字符串  
    - `fwirte()` / `fread()` 用于处理二进制模式文件  

    1. `size_t fwirte (const void *restrict ptr, size_t size, size_t nmemb, FILE * restrict fp);`  
        > `ptr`   待写入数据块的地址  
        > `size`  待写入数据的大小(字节)  
        > `nmemb` 待写入数据块的数量  
        > `fp`    待写入的文件  
        ```c
        double earnings [10];
        fwirte (earnings, sizeof (double), 10, fp); // 将10个double元素的数组写入到fp中
        ```

        - `fwirte()`函数返回值
            1. 成功返回写入数据项的数量,正常情况下返回值就是`nmemb`  
            2. 写入错误返回值会比`nmemb`小  

    2. `size_t fread (void *restrict ptr, size_t size, size_t nmemb, FILE * restrict fp);`  
        1. `fread (earnings, sizeof (double), 10, fp); //从fp中读取10个double类型的数据块`  
        2. `fread()`函数返回值  
            > 成功返回`nmemb`  
            > 读取错误或读到文件结尾EOF，该返回值会比`nmemb`小  


5. 写入错误检测`feof /ferror`函数  
    1. `int feof (FILE *fp) / int feeror (FILE *fp)`  

    - `标准i/o 函数`返回`EOF`， 通常表明函数已到达文件结尾  
    - 但是当出现读取错误时，函数也会返回`EOF`    
    2. `feof / ferror` 函数用于区分这两种情况  
        - 返回值  
        > `feof ()`,   上一次调用检测到文件结尾时，返回一个`!0`值，否则返回`0`  
        > `ferror ()`, 当出现读写错误，返回一个`!0`值，否则返回`0`

## 第十四章: 结构体 [返回顶部](https://github.com/GitNoWen/gitnowen/blob/master/arch_work/c/c-primer-plus/note.md#c-primer-plus---%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95)
---
> [关于结构体的相关了解] (https://en.cppreference.com/w/c/language/struct)  
---
> - 关键字: `struct, union, typedef`
> - 运算符: `.、->`
> - 结构体: 结构模板，结构变量
> - 访问结构体成员，处理结构体的函数
> - 联合指向函数的指针

### 14.1 结构体声明

- 结构体在内存中的存储结构与数组类似,每一个成员就是一个元素,但是结构体更加强大

1. 结构体关键字`struct`,描述了一个结构的组织布局   
    - 结构声明又称模板,结构体标记可选  
    ```c
    struct book {  //声明一个模板
       //结构标记为book
      //这个结构共有三个成员

      char title[10];    //书的标题
      char author[10];  //书本作者
      float value;     //价格
    }; //结构体声明结束，声明以分号结尾
    ```  
2. 结构体声明(模板),并未创建实际的数据对象，只是描述了该结构由什么组成  
3. 结构体成员可以为`任意C类型`,或其他`结构`  
4. 结构体声明可以放在函数内，也可以放在函数外，两者区别在于作用域不同  
5. 定义结构体变量  
    - 结构体变量声明为结构体变量`library`创建了三个存储空间
    ```c
    struct book library;  //声明了一个book结构的结构体变量  
     //为library 结构变量创建了三个book结构成员
    // title, author, value
    ```
6. 对计算机来说这种结构体和结构变量分开声明的方法与下面的方法一样
    ```c
    struct book {       //结构模板标记

      char title[10];
      char author[10];
      float value;
    } library;      //结构体布局和结构变量一起声明
    ```
7. 声明一个无需结构体标记的结构体变量
    ```c
    struct {     //无结构体标记

      char title;
    } library;//结构体变量
    ```
### 14.2 初始化结构

1. 在`ANSI C` 之前不能用自动变量初始化结构  
    - 变量可以初始化为静态存储期变量，存储类型对结构体一样适用  
    1. 列表初始化  
         ```c
         struct book library = {  //初始化
           //结构初始化，每一行对应相应结构体成员
           "The pious pirate and Devious Damsel", //title
           "Eenee Vivotte",                      // author
           1.95                                 //  value
         };   //结构初始化结束
         ```
    2. 指定初始化  
        - `c99`和`c11`提供指定初始化器  
        ```c
        struct book library = {.value = 1.9"};   //只初始化一个成员
        struct book library = {         //也可以不按顺序来初始化指定的成员

          .value  = 1.0,              //在模板中value 成员在author成员后面
          .author = "Stephen Prata",
          .title  = "C Primer Plus",
          10.2                     //所以与数组类似，value最后的值为10.2
        };
        ```

2. 访问结构体成员  
    - 结构体类似于一个`超级数组`, 这个数组由多种类型的元素组成  
    - 使用 点`.`符号来访问结构体中的成员  
    ```c
    library.title  = "hello c"; //访问结构体中的title 成员
    library.author = "myself";
    library.value  = 1.1;
    ```

### 14.3 结构数组

1. 声明的方法有多种
    ```c
    // 组合声明
    struct book { //结构布局

      char title[10];
      char author[10];
      float value;
    }library[10];  //这里是将结构体声明和结构体变量声明一起实现
    // 分离声明
    book books [10];
    ```
2. 初始化数组结构
    ```c 
    for (int a = 0; a < 10; a++)
    library[a]={ //利用循环将所有数组结构成员初始化

      "No title",
      "No author",
      0.0
    };
    ```
3. 访问数组结构成员
    ```c
    library[a].title = "C Primer Plus"
    // 其他成员类似
    ```

### 14.4 嵌套结构

1. 结构体中包含结构体
    ```c
    struct names { //名字结构，名和姓组成
      //第一个结构布局
      char first[5];
      char last[5];
    };

    struct guys {
      // 第二个机构体布局
      struct names handle; //结构体嵌套
      char job [10];
      long phone;
    }clase[2]; // 结构数组含有两个calse结构元素
    ```
2. 初始化嵌套结构体数组成员
    1. 分别将两个`clase`初始化
    ```c
    clase[0] = {

      {"mo", "wen"}, //初始化第一个嵌套结构体的成员
      "study",
      123456
    };
    ```
    ```c
    clase[1] = {

      {"mo", "wen"},
      "study",
      123232
    }
    ```
    2. 在声明嵌套结构数组时一起初始化 
    ```c
    struct guy clase[2] = { //声明并初始化

      {//第一个结构数组元素

        {"mo", "wen"},
        "study",
        123456
      },{//第二个结构数组元素

        {"an", "kuo"},
        "work",
        123131
      }
    };  //END
    ```
3. 访问嵌套结构体成员
    - 每一层结构体需要用一点`.`运算符
    ```c
    clase[0].hendle.first = "mo";
    clase[0].hendle.last = "wen";

    clase[1].hendle.first = "an";
    clase[1].hendle.last  = "kuo";
    ```

### 14.4 指向结构的指针

1. 声明一个指向结构体的指针
    ```c
    struct guy *ClaseP;
    // 声明一个指向guy结构的指针
    ```
    - 结构体指针指向一个结构
    ```c
    ClaseP = &clase[0]; //指向嵌套结构数组第一个元素
    // == ClaseP = clase; 数组名就是首元素地址,结构变量要用&
    ```
    2. 通过结构体指针引用结构体中的值
    ```c
    ClaseP->phone; //== calse[0].phone;
    //引用嵌套结构体中的值
    (*ClaseP).names.first; //== clase.names.first;
    ```
    3. 用结构指针传递结构给函数
        - 和数组传参一样，效率更高

### 14.5 传递结构的信息  

1. 在`ANSI C` 之前不允许将一个结构作为参数传递  
    - 但是早期的协议支持将结构指针作为参数传递  

2. 使用结构指针传参跟数值和指针的传参关系一样，使用指针效率更高  

3. 传递结构体成员  
    ```c
    void add (int n); //声明一个函数
    strcut num {int n;}num;
    void add (num.n); //传递一个结构成员
    ```
4. 传递结构地址  
    ```c
    void tem (struct num *numble);//声明一个接受结构地址的函数
    struct num numble;
    void tem (&numble);
    ```
5. 传递一个结构  
    ```c
    void nu (struct num numble); //声明一个接受结构参数的函数
    struct num {int n;}numble;
    void nu (numble); //拷贝一份结构副本
    ```
6. 其他结构特性 (`c99`)  
    1. 同一个模板的结构支持将一个结构赋值给另一个结构  
    ```c
    struct a{ //模板声明加定义
      int a;
      int b;
    }num = {2,3};
    struct a ta = num; //直接初始化一个新的a结构类型的变量
    ```
    2. `ANSL C`接受把一个结构作为返回值返回给主调函数
    ```c
    struct a bk(struct a tem);
        ...
    struct a bk(struct a tem){
        ...
      return tem;
    }
    ```

### 14.6 用指针访问结构体成员

1. 结构体指针操作符`->`,仅限于结构指针  
    - 点`.`运算符优先级高于`->`运算符  
    ```c
    struct a{ //
    int a;
    }a1;
    struct a *pst = &a1; //指向结构体
    pst->a = 1; //== a1.a;

    //结构体数组
    struct a {
      int a;
    }ar[5];
    struct a *pst = ar;//指向第一个结构数组第一个结构元素ar[0]
    (*pst).a = 1; //== ar[0].a
    pst->a
    ```

### 14.7 如何选择传递结构还是传递结构指针  

    1. 结构指针  
        1. `ANSL C` 之前必须使用指针的实现传参  
        2. 指针传参效率高，损耗低  
        3. 缺点是无法保护数据(误操作修改),`c99`标准开始支持`cosnt`解决了这个问题  

    2. 结构  
        1. 函数处理的是结构的副本，保护了数据  
        2. 相比之下使用传递结构的函数可读性更高    

### 14.8 结构中使用指针变量与`malloc`  

    - 使用指针的结构更加高效  
    ```c
    struct a {

      int *b1; //未初始化的指针
    }an;
    an.b1 = (int*)malloc (sizeof(int)*2);
    free (an.b1);
    ```

### 14.9 结构复合字面量(`c99`)

    - 使用  

    ```c
    struct a an2 = (struct a){2};
    ```

### 14.10 伸缩型数组成员 (`c99`)  

    - 含有伸缩型数组的结构  
    - 结构的最后一名成员具有一些特性  
        - 若声明一个普通结构变量，则结构内的伸缩数组不可访问
        - 若分配内存时未额外为期分配内存，则数组长度为`1`个元素长度 
        ```c
        struct a *b;//b 指向一个含有伸缩数组的结构
        b = malloc (sizeof (struct a)); //没有给变长数组额外分配内存
        // 所以伸缩数组的长度应该为1个数组元素
        ```
        - 使用伸缩型数组成员，可以编写合适的代码  
    - 声明一个伸缩型数组成员的规则  
        - 伸缩型数组必须是结构体的最后一名成员  
        - 结构体中还必须包含至少一名其他成员  
        - 与普通数组声明类似，但是中括号是空的  
    - 声明一个结构体变量是不能对伸缩型数组做任何事的  
    - 需要声明一个结构体指针来给伸缩型数组分配内存  
    ```c
    struct a {

      int n;    //至少要有一个结构成员
      int ar[];//伸缩型数组成员
    }num; //普通结构体变量
    struct a *pnum = mallloc (sizeof(struct a) + 5*sizeof (int));
                    // sizeo(struct a)为struct a结构体中其他成员分配空间, 
                   // 5 * sizeof (int) 为伸缩型数组
    ```
    - 含有伸缩型数组的结构需要注意  
        1. 如果两个同样类型的结构直接赋值  
        ```c
        struct a *pnum,*pnum2;
        *pnum = *pnum2; //这样只会拷贝除伸缩型数组之外的其他成员
        ```
        2. 不要以按值的方式把带有伸缩数组的结构传递给普通结构  
            - 因为伸缩数组的长度的不确定性  
        3. 不要将含有伸缩数组的结构做嵌套或数组成员  

### 14.11 匿名结构  

    - 没有标记的结构
    ```c
    struct a{

      int a;
      struct { //匿名结构

        int b;
      };
    }a;
    ```
    - 初始化  
    `struct a = {1,{2}};`  

### 14.12 联合类型

1. 什么是联合  
    - 一种数据类型    
    - 在不改变内存空间的情况下,存放一个不同类型的数据  
    - 多用于存储无序，无规律的混合数据  

2. 联合与结构的不同之处  
    - 结构可以按结构模板存储多个不同类型的数据  
    - 联合只能存储一个数据，但是可以是联合模板中定义的任意数据类型之一  

3. 定义一个联合数据模板  
    - 其定义方法和结构定义方法一样  
    ```c
    union number { //number模板

      int num1;
      float num2;
      double num3;
    };
    ```

4. 访问联合数据  
    - 与结构一样  
    ```c
    union a{

      int na;
      float fa;
    }una;
    una.fa = 14.2; //存储一个float类型数据
    una.na = 1; //存储一个int 类型数据
    // una中只有一个数据,重新赋值将会清除上一个数据
    union a *ap; //声明一个a类型union指针
    ap = &una;  // 指向联合变量
    ap->int = 1;//通过->操作对象
    ```

### 14.13 匿名联合(c11)
    - 使用方法和匿名结构一样
    ```c
    struct a{int na; int na2;};
    struct b{float fb; float fb2};
    
    struct num {

      double dnum;
      union {

        struct a intnum;
        struct b floatnum;
      }
    }number;
    number.intnum.na = 1;
    number.floatnum.fb = 1.0;
    ```
### 14.14 枚举
    - `enum`,创建一个新"类型"并指定它可具有的值
    - 枚举常量是`int`类型，能用`int`类型就可以用枚举
    - 声明方法和结构一样
    ```c
    enum new {a,b,c,d}ch; //创建一个new类型的enmu变量ch可以具有a, b, c, d四种值
    ```
    - C语言的枚举有一些特性与C++不兼容
    ```c
    ch++; //c++中不允许枚举使用++
    int ch;
    ch++; //只能将其声明为int类型
    ```
    - 默认情况下，枚举常量第一个成员值从`0`开始依次递增`1`

### 14.16 名称空间
    - 作用域属于名称空间概念的一部分
    - 在同一作用域内，不同的命名空间的标识符可以一样，不发生冲突
    ```c
    //在同一个块中，同一作用域
    struct c {int a;};// 结构标签和联合标签属于同一命名空间
    union a {int a;};//  结构联合成员术语不同命名空间
    enum {a, b, d}Enum; //枚举成员和变量属于同一命名空间
    int c;          // 变量名
    ```
### `typedef` 
    - 利用`typedef` 可以为某一类型自定义名称，与`#define`类似  
    - 不同  
       - `typedef` 创建的符号名受限于类型而不是值  
       - `typedef` 由编译器解释而不是预处理器
       - 受限范围内，`typedef`比`#define`灵活
    - 使用
    ```c
    typedef char * string;
    string strs, names; // == char *strs, *names;
    ```
    - 常用于给复杂的类型创建一个类名


## 第十五章:位操作

> 运算符:`~`, `&`, `|`, `^`  
  `<<<`, `>>`, `&=`, `|=`, `^=`    
  `>>=`, `<<=`  

> 二进制，十进制，十六进制计数    

> 位运算符，位域  

> `_Alignas`, `_Alignof`

---







---

# 随记 [返回顶部](https://github.com/GitNoWen/gitnowen/blob/master/arch_work/c/c-primer-plus/note.md#c-primer-plus---%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95)


- 函数也有地址  
   - 函数在代码段中一直存在  

- 指针函数  
```c
int * fun{
}
//拥有函数体
```

- 函数指针  
    - 一个变量，用来调用函数  
`void (*ponc)(void); //名字为ponc 的函数指针,第一个表示返回值类型，第二个void 表示指向的类型`

- 利用typedef 创建一个函数指针类型  
```c
typedef void (*Ponc) (void);
Ponc fun(void); //实际是声明了一个 void*Ponc(void) 类型的函数 void fun (void);
void (*fp) (void);  // fp函数指针
fp = fun;函数指针指向fun;
调用
(*fp)();         //显示调用
  fp();         //隐式调用
```

- 创建一个指向函数指针的函数指针
```c
typedef void (*FP) (void);
typedef void (*PFP) (FP);
PFP PFP_pt;
```

- 哑值 `dummy value`  
    - 定义一个变量，随便给出一个初始值，不让变量空闲在那的意思  

- 位段/位域
    - c语言允许在结构体中以`位`为单位指定其成员所占的`内存长度`  
    - 有时只需要使用到`1位(0/1)`来表示信息(表示真或假),可以用较少的位数存储数据
    struct a {
      int num:1;//num占1位的大小,只能表示0或1
    };
    - 无名位域
    ```c
    int :0;
    //没有标识符，无法初始化，用于填充内存布局，只有无名位域可以为0位
    //用于强迫内存对齐
    ```
* 而位域这种数据结构的缺点在于  
  其内存分配与内存对齐的实现方式依赖于具体的机器和系统  
  在不同的平台可能有不同的结果  
  这导致了位段在本质上是不可移植的  
- 声明  
    - 在声明时，位段成员必须是整形或枚举类型(通常是无符号类型)    


- 内存对齐与结构体  
    - 结构体成员按定义时的顺序依次存储在连续的内存空间  
    - 没有成员的结构体占`0`字节,`c++`中占`1字节`  
    - 默认的内存对齐规则是有cpu位数决定  
        - `32位-4字节, 64位-8字节`  
    - 结构体中按照以最大字节的类型为标准补齐  
    ```c
    struct a {//64位平台

      int n;    // 4字节,少于8字节补4
      double d;//  8字节,最大字节类型
      char c; //   1字节,补够8字节
    }b1;     // int(4+4)+double(8)+char (1+7) = 24字节
//=====================
    struct a1 {

      double d; // 最大字节
      int n;   //  4字节补够8字节
      char c; //   占一个字节,计入int补齐字节中
    }b2;     // 8+(4+4) = 16字节
    ```
# 清屏命令
1.   include stdlib.h > system("clear");  

3.    printf("\033[2j]");  

# 白痴错误集锦
#### 2020-07-24 更新
    在clang编译器中:
    ```c
    void ar(char *);
    int main {char a [5] = "abcd"; ar(a);}
    void ar(char *ar){
      *a+1 = 'e';//错误　值＝值
    }
    ```

